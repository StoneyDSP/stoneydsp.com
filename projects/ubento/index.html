<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" prefix="og: https://ogp.me/ns#">

  <head>
    <meta charset="UTF-8" />

    <base href="https://www.stoneydsp.com" />

    <link rel="preconnect" href="https://www.stoneydsp.com/" crossorigin />
    <link rel="dns-prefetch" href="https://www.stoneydsp.com/" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="google-site-verification" content="U222mQRVBnX_8XrWZU9c6ETanVW8lFK6jvhJFQwtcdE" />
    <meta name="google-site-verification" content="RGeh6hqM-ZZ-p0iM4G9NekMKA5RJmK-3qsmVmghRA6o">
    <meta name="google-site-verification" content="y0AZ7IKx9YPJJRWr25AKxgvOufRvppoI8VWq504mU6I">
    <meta name="robots" content="all" />

    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-WCM3NS5C');</script>
    <!-- End Google Tag Manager -->

    <meta property="og:description" content="Minimal, bento-box style Ubuntu-based WSL distro front-end" />
    <meta property="og:title" content="StoneyDSP/UBento">
    <meta property="og:url" content="https://www.stoneydsp.com/projects/index.html">
    <meta property="og:image" content="https://www.stoneydsp.com/public/icon__512x512.png">
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:width" content="512">
    <meta property="og:image:height" content="512">
    <meta property="og:image:alt" content="Minimal, bento-box style Ubuntu-based WSL distro front-end" />

    <meta property="twitter:card" content="summary" />
    <meta property="twitter:title" content="StoneyDSP/UBento" />
    <meta property="twitter:description" content="Minimal, bento-box style Ubuntu-based WSL distro front-end" />
    <meta property="twitter:image" content="https://www.stoneydsp.com/public/icon__512x512.png" />

    <link rel="canonical" href="https://www.stoneydsp.com/projects/ubento/index.html">
    <link rel="shortlink" href="https://stoneydsp.com/projects/ubento/">

    <link rel="sitemap" type="application/xml" title="Sitemap" href="/www-sitemap.xml" />
    <link rel="manifest" href="/stoneydsp.webmanifest" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link href="/src/assets/css/styles.css" rel="stylesheet" type="text/css">
    <script type="text/javascript" src="/api/index.js"></script>
    <script type="text/javascript" src="/src/assets/js/jquery/jquery.js"></script>
    <script type="text/javascript" src="/src/assets/js/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="/src/assets/js/doxygen/search/searchdata.js"></script>
    <script type="text/javascript" src="/src/assets/js/doxygen/search/search.js"></script>
    <script type="text/x-mathjax-config">
			MathJax.Hub.Config({
				extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
				jax: ["input/TeX","output/HTML-CSS"],
			});
		</script>
    <script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js"></script>
    <script type="text/javascript" src="/src/assets/js/doxygen/darkmode_toggle.js"></script>
    <script>window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };</script>
    <script defer src="/_vercel/insights/script.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-HZNXN8FLSK"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-HZNXN8FLSK');
    </script>

    <meta name="description" content="Minimal, bento-box style Ubuntu-based WSL distro front-end">
    <title>StoneyDSP: UBento</title>

  </head>

  <body>

    <!-- Google Tag Manager (noscript) -->
    <noscript>
      <iframe
        src="https://www.googletagmanager.com/ns.html?id=GTM-WCM3NS5C"
        height="0"
        width="0"
        style="
          display:none;
          visibility:hidden
        "
        >
      </iframe>
    </noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="top">
      <!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectalign">
                <div id="projectname">
                  <a href="https://stoneydsp.com/" class="projectname">StoneyDSP</a>
                  &#160;/&#160;UBento<span id="projectnumber">&#160;1.0.3</span>
                </div>
                <div id="projectbrief">Minimal, bento-box style Ubuntu-based WSL distro</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->

      <!-- Generated by Doxygen 1.9.7 -->
      <script type="text/javascript">
			/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
			var searchBox = new SearchBox("searchBox", "/public/search/",'.html');
			/* @license-end */
		</script>

      <script type="text/javascript" src="/src/assets/js/doxygen/menudata.js"></script>
      <script type="text/javascript" src="/src/assets/js/doxygen/menu.js"></script>
      <script type="text/javascript">
			/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
			$(function() {
			initMenu('',true,false,'search.php','Search');
			$(document).ready(function() { init_search(); });
			});
			/* @license-end */
		</script>

      <div id="main-nav"></div>

    </div>
    <!-- top -->

    <!-- window showing the filter options -->
    <div id="MSearchSelectWindow"
      onmouseover="return searchBox.OnSearchSelectShow()"
      onmouseout="return searchBox.OnSearchSelectHide()"
      onkeydown="return searchBox.OnSearchSelectKey(event)">
    </div>

    <!-- iframe showing the search results (closed by default) -->
    <div id="MSearchResultsWindow">
      <div id="MSearchResults">
        <div class="SRPage">
          <div id="SRIndex">
            <div id="SRResults"></div>
            <div class="SRStatus" id="Loading">Loading...</div>
            <div class="SRStatus" id="Searching">Searching...</div>
            <div class="SRStatus" id="NoMatches">No Matches</div>
          </div>
        </div>
      </div>
    </div>

    <div>
      <div class="header">
        <div class="headertitle">
          <div class="title">
            <h1>UBento</h1>
          </div>
        </div>
      </div>
      <!--header-->
      <div class="contents">
        <div class="textblock">
          <p>
            <a class="anchor" id="md__r_e_a_d_m_e"></a>Minimal, bento-box style Ubuntu-based WSL distro front-end, ideal for targeting Linux-style NodeJs and CMake development environments from Windows platforms.
          </p>
          <p>
            <img src="/public/icon__512x512.png" alt="UBento-icon" class="inline">
          </p>
          <p>Quick start (see 'requirements');</p>
          <div class="fragment">
            <div class="line"># Download ubento.tar from the releases page to &quot;C:\Users\${username}\ubento.tar&quot;</div>
            <div class="line"># Import Ubento into WSL and launch;</div>
            <div class="line">&gt; wsl --import UBento &quot;C:\Users\${username}\UBento&quot; &quot;C:\Users\${username}\ubento.tar&quot;</div>
            <div class="line">&gt; wsl -d UBento</div>
            <div class="line">$ make_user &quot;${username}&quot; &quot;${full name}&quot;</div>
            <div class="line"># Supply and confirm a password... and welcome to UBento :)</div>
          </div>
          <!-- fragment -->
          <p>Alternative - Build from source (see 'requirements' and [TIPS]:Building from source);</p>
          <div class="fragment">
            <div class="line">&gt; docker run -it ubuntu bash ls /</div>
            <div class="line">&gt; docker export -o &quot;C:\Users\${username}\ubuntu.tar&quot;  ${distronumber}</div>
            <div class="line">&gt; wsl --import UBento &quot;C:\Users\${username}\UBento&quot; &quot;C:\Users\${username}\ubuntu.tar&quot;</div>
            <div class="line">&gt; wsl -d Ubento</div>
            <div class="line"># Copy UBento files (see README.md!)</div>
            <div class="line">$ make_user &quot;${username}&quot; &quot;${full name}&quot;</div>
            <div class="line"># Supply and confirm a password... and welcome to UBento :)</div>
          </div>
          <!-- fragment -->
          <h2>
            <a class="anchor" id="autotoc_md1"></a>
            About</h2>
          <p>
            The WSL Ubuntu distro that is available from the MS Store is initialized via a snap called "install RELEASE", and also comes bundled with a rather hefty APT package suite called <code>ubuntu-wsl</code>. The MS Store Linux distros are also generally bundled with the "WSL2 Distro Launcher", which provides for example the 'Ubuntu.exe' on the Windows-side. This is a nice interoperability, but particularly the snap requirements are quite costly in both storage and performance.
          </p>
          <p>The MS Store Ubuntu distro also contains quite a large stash of Bash completion helpers and scripts, covering many packages and libraries that are not actually to be found on the base install but which are still updated regularly at source (e.g., CMake), and the standard APT keyring which holds many outdated packages (e.g., NodeJs v.12...?), yet does not provide other common developer packages (e.g., Yarn) by default.</p>
          <p>
            Instead, we can pull Ubuntu-Minimal - Approx. 74mb - from a Docker container image, and launch that in WSL directly. Ubuntu-Minimal also has the <code>unminimize</code>
            command which rehydrates the install into the full "interactive login" version of Ubuntu; from there, we can build a much more streamlined Ubuntu with fewer runtime dependencies and practically no Linux-side background service requirements of it's own (compare by running <code>service --status-all</code>
            ) and tailor the environment towards a full-powered development environment with full GUI/desktop support via an encrypted Windows X-Server, <em>and</em> with a much reduced storage footprint, a fully up-to-date package registry, and - in many cases, - highly improved runtime performances.
          </p>
          <p>This will hopefully all get compiled into some sort of an interactive bash script... if time permits. Meanwhile, you can check the files provided here in the repo to get the idea - copying these simple bash scripts into the Ubuntu-Minimal docker distro and installing/running a few standard packages is all that is required to achieve the above goals of UBento.</p>
          <h2>
            <a class="anchor" id="autotoc_md2"></a>
            System Requirements:</h2>
          <ul>
            <li>Windows 11 22h2 or greater</li>
            <li>WSL2 (Windows Subsystem for Linux), optionally with a working Linux kernel/distro</li>
          </ul>
          <h2>
            <a class="anchor" id="autotoc_md3"></a>
            Optional:</h2>
          <ul>
            <li>VSCode with Remote Development Extensions, used for editing your code hosted on the WSL2 backend</li>
            <li>X-Server for Windows such as VcXsrv or X410 for GUI/desktop support if desired</li>
            <li>Docker Desktop for Windows using the WSL2 backend, used for obtaining and running developer environment images and building from source</li>
          </ul>
          <h2>
            <a class="anchor" id="autotoc_md4"></a>
            Todo:</h2>
          <ul>
            <li>Finish X-Server encryption helper function</li>
            <li>
              Use the shared <code>$WSLENV</code> variable to optionally link the distro userspace, to the Windows userspace
            </li>
            <li>
              Try <code>$WSLENV</code> for sharing a single, translatable path to an '.Xauthority' key between both userspaces (this works for SSH keys and symlinks...)
            </li>
            <li>
              Investigate usage of user-login password as an MIT-encrypted env variable (like <code>{{ git.SECRET }}</code> ) for use with Git control, intializing DBus with as sudo during startup routine, authenticating the X-Server encryption layer step, and so on
            </li>
            <li>Implement as a shell-scripted front-end for a fast, flexible, potentially CI-capable* Ubuntu-Minimal deployment</li>
          </ul>
          <p>
            *where the <code>unminimize</code> command and other rehydrations can be averted from use cases.
          </p>
          <h2>
            <a class="anchor" id="autotoc_md5"></a>
            Notes:</h2>
          <ul>
            <li>
              Run the suggested instructions in either your Windows Powershell (<code>&gt;</code>
              ), or your current WSL2 distro's terminal (<code>$</code>
              ), but obviously don't bother entering the comment lines (<code>#</code>
              ). Make sure to fill in the blanks where <code>&lt;variables&gt;</code> are concerned.
            </li>
            <li>
              Neither <code>unminimize</code> nor systemd are really required for most developing purposes - see [TIPS].
            </li>
            <li>Check the [TIPS] and [TROUBLESHOOTING] sections for helpful insights.</li>
            <li>Try it with other Linux flavours and goals.</li>
          </ul>
          <p>
            <img src="https://c4.wallpaperflare.com/wallpaper/884/285/193/windows-10-tux-linux-gnu-hd-wallpaper-preview.jpg" alt="Creepy-Penguin" class="inline">
          </p>
          <p>
            To get started, run the below in either your Windows Powershell (<code>&gt;</code>
            ) or your Linux Bash (<code>$</code>) terminal;
          </p>
          <h2>
            <a class="anchor" id="autotoc_md6"></a>
            [PRE-INSTALL]</h2>
          <p>First, we need to get a copy of the distro and import it into WSL, all on the Windows-side. There are currently two different strategies to achieve this; a quick-start method that will have all the benefits of UBento pre-loaded and ready to be executed, or alternatively you can choose to build a distro from source, and follow the suggestions and specifications highlighted in this document for yourself (see "[TIPS]:Building from source").</p>
          <ul>
            <li>
              <p class="startli">Opt 1 - Download the pre-configured distro for a quick start;</p>
              <p class="startli">
                Check the "Releases" page here and grab the latest UBento version, which should specifically be a .tar file with no further extension types; i.e., <code>ubento-v1-0-1.tar</code>.
              </p>
            </li>
          </ul>
          <p>Then, you can use WSL to directly import that .tar file, immediately launching a mostly-configured UBento as 'root' user, by proceeding to the next step.</p>
          <ul>
            <li>
              <p class="startli">Opt 2 - Pull Ubuntu-Minimal from a Docker Desktop image into .tar (Approx. 74mb) to build from source</p>
              <div class="fragment">
                <div class="line">&gt; docker run -it ubuntu bash ls /</div>
              </div>
              <!-- fragment -->
              <p class="startli">Take a note of the container ID of the Ubuntu image that was just running, then export it to some handy Windows location, using the .tar extension (WSL can then import it directly), as follows;</p>
              <div class="fragment">
                <div class="line">&gt; docker container ls -a</div>
                <div class="line">&gt; docker export -o &quot;C:\Users&lt;username&gt;\ubuntu_minimal.tar&quot; &quot;&lt;UbuntuContainerID&gt;&quot;</div>
              </div>
              <!-- fragment -->
              <p class="startli">NOTE: If you're choosing option 2 of the above - building a distro from source, by pulling a clean Ubuntu image from Docker Desktop and importing it - then I strongly suggest scrolling down to [TIPS:Building from source] for a clear understanding of the difference between the image hosted on the UBento "Release" page, and the Ubuntu image hosted by Docker. If building from source, the majority of this document only applies if you follow the provided instructions in [TIPS] correctly, before proceeding any further. If you choose to deviate from these instructions, you will simply have to adjust all the given advice accordingly - just a friendly dev-to-dev FYI :)</p>
            </li>
          </ul>
          <h2>
            <a class="anchor" id="autotoc_md7"></a>
            Importing the .tar file to run as a distro in WSL</h2>
          <p>
            We then have a few options for how we wish to store UBento, such as using the dynamic virtual hard drive (.vhd or .vhdx) format, and backing up and/or running from external storage drives. The <code>--export</code> command in the below example stores a backup mountable image in the 'D:\' drive (which can be a smart card or USB memory, etc), but you may of course place the files anywhere you like (see [TIPS] for more storage examples).
          </p>
          <div class="fragment">
            <div class="line">&gt; wsl --import UBento &quot;C:\My\Install\Folder&quot; &quot;C:\Users&lt;username&gt;\ubento.tar&quot;</div>
            <div class="line"> </div>
            <div class="line">&gt; wsl --export UBento &quot;D:\My\Backup\Folder\ubento.vhdx&quot; --vhd</div>
          </div>
          <!-- fragment -->
          <h2>
            <a class="anchor" id="autotoc_md8"></a>
            Backing up for restarting with a clean slate;</h2>
          <p>
            It later turns out to be handy to run that previous <code>--export</code> argument around this stage, or whenever you feel you have a good starting point;
          </p>
          <div class="fragment">
            <div class="line">&gt; wsl --export &lt;myPerfectDistro&gt; &quot;D:\My\Backup\Folder\my_perfect_distro.vhdx&quot; --vhd</div>
          </div>
          <!-- fragment -->
          <p>This is because if/when we screw anything up in our distro and want to start over from scratch, we can then simply;</p>
          <div class="fragment">
            <div class="line">&gt; wsl --unregister &lt;myBadDistro&gt;</div>
            <div class="line"> </div>
            <div class="line">&gt; wsl --import &lt;myPerfectDistro&gt; &quot;D:\My\Install\Folder&quot; &quot;D:\My\Backup\Folder\my_perfect_distro.vhdx&quot;</div>
          </div>
          <!-- fragment -->
          <p>
            And that puts us back to exactly where we last ran the <code>--export</code> command. Please see the [TIPS] section for much more advice on distro importing, exporting, and storage.
          </p>
          <h2>
            <a class="anchor" id="autotoc_md9"></a>
            Check UBento is installed and launch it;</h2>
          <div class="fragment">
            <div class="line">&gt; wsl -l -v</div>
            <div class="line"># UBento should be listed amongst your WSL distros...</div>
            <div class="line"> </div>
            <div class="line"> </div>
            <div class="line">&gt; wsl -d UBento</div>
            <div class="line"># The docker Ubuntu Minimal image we pulled earlier - now named &#39;UBento&#39; - will now launch in the terminal...</div>
          </div>
          <!-- fragment -->
          <h2>
            <a class="anchor" id="autotoc_md10"></a>
            [POST-INSTALL]</h2>
          <p>
            The below steps are to be run from within your new WSL Ubuntu-based bash terminal (<code>$</code>).
          </p>
          <ul>
            <li>set permission for root folder (see '[TIPS]:Building from source' for info on this command), restore server packages, and install basic dependencies;</li>
          </ul>
          <div class="fragment">
            <div class="line">$ init_permissions</div>
            <div class="line">$ apt update &amp;&amp; apt install apt-utils dialog</div>
            <div class="line"> </div>
            <div class="line"># If you need superuser accesses...</div>
            <div class="line">$ apt install sudo &amp;&amp; sudo -s</div>
            <div class="line"> </div>
            <div class="line"># If you wish to &#39;rehydrate&#39; from Minimal to a fully interactive, login-based install...</div>
            <div class="line">$ yes | unminimize</div>
            <div class="line"> </div>
            <div class="line"># Choose which base packages you need, I suggest something like these...</div>
            <div class="line">$ apt install less manpages nano vim gawk grep bash-completion bash-doc git curl wget libreadline8 readline-common readline-doc resolvconf gnu-standards xdg-user-dirs openssl ca-certificates lsb-release xauth</div>
            <div class="line"> </div>
            <div class="line"># Clear the APT cache if you like...</div>
            <div class="line">$ rm -rf /var/lib/apt/lists/*</div>
          </div>
          <!-- fragment -->
          <h2>
            <a class="anchor" id="autotoc_md11"></a>
            [CREATE USER]</h2>
          <ul>
            <li>
              named "username" (could use <code>$WSLENV</code> to pull your Win user name here - stay tuned) with the required UID of '1000'. You will be prompted to create a secure login password for your new user;
            </li>
          </ul>
          <div class="fragment">
            <div class="line">$ export username=&quot;&lt;Your Username Name&gt;&quot;</div>
            <div class="line">$ export fullname=&quot;&lt;Your Full Name&gt;&quot;</div>
            <div class="line">$ export email=&quot;&lt;Your Email&gt;&quot;</div>
            <div class="line"> </div>
            <div class="line">make_user()</div>
            <div class="line">{</div>
            <div class="line">    adduser --home=/home/&quot;${1}&quot; --shell=/bin/bash --gecos=&quot;${2}&quot; --uid=1000 &quot;${1}&quot;</div>
            <div class="line"> </div>
            <div class="line">    usermod --group=adm,dialout,cdrom,floppy,tape,sudo,audio,dip,video,plugdev &quot;${1}&quot;</div>
            <div class="line"> </div>
            <div class="line">    login ${1}</div>
            <div class="line"> </div>
            <div class="line">    git config --global user.name &quot;${1}&quot;</div>
            <div class="line"> </div>
            <div class="line">    git config --global user.email &quot;${3}&quot;</div>
            <div class="line"> </div>
            <div class="line">    echo -e &quot;[user]\n default=${1}\n&quot; &gt;&gt; /etc/wsl.conf</div>
            <div class="line">}</div>
            <div class="line"> </div>
            <div class="line">$ make_user &quot;${username}&quot; &quot;${fullname}&quot; &quot;${email}&quot;</div>
            <div class="line"> </div>
            <div class="line"># The output of the above function will prompt you to create and confirm a secure login password, then to repeat it again to complete the actual log in process. Once complete, you will be in your linux user-space</div>
          </div>
          <!-- fragment -->
          <p>
            From now on, you can use <code>sudo</code>
            invocations from your new user login shell (assuming you already installed sudo), and will also have access to useful system commands like <code>sudo apt update &amp;&amp; sudo apt ugrade</code>.
          </p>
          <p>
            Back in Powershell (<code>&gt;</code>
            ), we can now login as our new user (the <code>--user</code>
            argument here shouldn't be necessary due to the 'default user' setting in <code>/etc/wsl.conf</code>
            , but it doesn't hurt to be sure here on this first re-launch, as this <em>ensures</em> we run finish critical initialization procedure correctly!)
          </p>
          <div class="fragment">
            <div class="line">&gt; wsl -d UBento --shutdown</div>
            <div class="line">&gt; wsl -d UBento --user &quot;${username}&quot;</div>
          </div>
          <!-- fragment -->
          <p>
            <em>You can also adapt the above command for launching a Windows Terminal profile, for example (see [TIPS]).</em>
          </p>
          <h2>
            <a class="anchor" id="autotoc_md12"></a>
            At this point, the distro remains minimal yet fully scalable, GUI apps and Windows integration should be working, and UBento is well-configured to continue on as you please...</h2>
          <p>...but, the idea with UBento is take some minimal steps to greatly enhance the experience where possible. We can choose to tailor our UBento towards either/both a fully-configured desktop environment, and/or a fully-configured development environment; the scripts below are presented as suggestions, largely based on exposed defaults that can be found on actual Linux desktop machines made portable - and, with small tweaks to further explore some of the more useful, powerful, and interesting desktop interoperability opportunities that an otherwise feather-weight WSL/Ubuntu-Minimal distro can provide.</p>
          <p>
            <img src="https://raw.githubusercontent.com/StoneyDSP/ubento/main/ubento.png" alt="UBento-icon" class="inline">
          </p>
          <h2>
            <a class="anchor" id="autotoc_md13"></a>
            [DEVTOOLS KEYRING]</h2>
          <p>
            The following bash functions are already pre-defined in the root user's <code>~/.bashrc.d/bash_keyring.sh</code>
            , which is accessed by called <code>sudo -s</code>
            (to enter a shell as the root user with sudo privileges), then just entering the name of the function, such as <code>get_node</code>
            . Back in your user-space you then just <code>sudo apt install nodejs</code>
            to install the latest release, per the function definition. If any of them don't work, just make sure that <code>sudo</code>
            has the above export locations when doing <code>get_&lt;key&gt;</code>.
          </p>
          <p>These are reproduced here in altered form for convenience and testing. The following function convention is just an "average", based on the APT-key instructions provided by each vendor, which all vary slightly but more or less follow the below formula ('get key, add to lst, update cache'...).</p>
          <p>Requires some of the basic packages from earlier, such as wget/curl/git/gpg/lsb-release/openssh-client.</p>
          <div class="fragment">
            <div class="line">$ sudo -s</div>
            <div class="line">$ apt install wget curl git gpg lsb-release openssh-client</div>
            <div class="line"> </div>
            <div class="line">$ export DISTRO=&quot;$(lsb_release -cs)&quot;</div>
            <div class="line">$ export ARCH=&quot;$(dpkg --print-architecture)&quot;</div>
            <div class="line">$ export APT_SOURCES=&quot;/etc/apt/sources.list.d&quot;</div>
            <div class="line">$ export KEY_PATH=&quot;/usr/share/keyrings&quot;</div>
          </div>
          <!-- fragment -->
          <ul>
            <li>Node (latest)</li>
          </ul>
          <div class="fragment">
            <div class="line">$ get_node()</div>
            <div class="line">{</div>
            <div class="line">    local NODEJS_KEY=&quot;$KEY_PATH/nodesource.gpg&quot;</div>
            <div class="line"> </div>
            <div class="line">    local SYS_NODE_V=&quot;node_19.x&quot;</div>
            <div class="line"> </div>
            <div class="line">    curl -fsSL https://deb.nodesource.com/gpgkey/nodesource.gpg.key | gpg --dearmor | tee $NODEJS_KEY &gt;/dev/null</div>
            <div class="line"> </div>
            <div class="line">    echo &quot;deb [arch=$ARCH signed-by=$NODEJS_KEY] https://deb.nodesource.com/$SYS_NODE_V $DISTRO main&quot; | tee $APT_SOURCES/nodesource.list</div>
            <div class="line"> </div>
            <div class="line">    echo &quot;deb-src [arch=$ARCH signed-by=$NODEJS_KEY] https://deb.nodesource.com/$SYS_NODE_V $DISTRO main&quot; | tee -a $APT_SOURCES/nodesource.list</div>
            <div class="line"> </div>
            <div class="line">    apt update</div>
            <div class="line">}</div>
            <div class="line"> </div>
            <div class="line">$ apt install nodejs</div>
            <div class="line"> </div>
            <div class="line">$ npm --global install npm@latest</div>
          </div>
          <!-- fragment -->
          <ul>
            <li>Yarn (latest)</li>
          </ul>
          <div class="fragment">
            <div class="line">$ get_yarn()</div>
            <div class="line">{</div>
            <div class="line">    local YARN_KEY=&quot;$KEY_PATH/yarnkey.gpg&quot;</div>
            <div class="line"> </div>
            <div class="line">    curl -fsSL https://dl.yarnpkg.com/debian/pubkey.gpg | gpg --dearmor | tee $YARN_KEY &gt;/dev/null</div>
            <div class="line"> </div>
            <div class="line">    echo &quot;deb [arch=$ARCH signed-by=$YARN_KEY] https://dl.yarnpkg.com/debian stable main&quot; | tee $APT_SOURCES/yarn.list</div>
            <div class="line"> </div>
            <div class="line">    apt update</div>
            <div class="line">}</div>
            <div class="line"> </div>
            <div class="line">$ apt install yarn</div>
            <div class="line"> </div>
            <div class="line">$ yarn global add npm@latest</div>
          </div>
          <!-- fragment -->
          <ul>
            <li>
              Node Version Manager (note that it will install into <code>$XDG_CONFIG_DIR</code>
              , so <code>$HOME/.config/nvm</code>)
            </li>
          </ul>
          <div class="fragment">
            <div class="line">$ get_nvm()</div>
            <div class="line">{</div>
            <div class="line">    curl -o- &quot;https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh&quot; | bash</div>
            <div class="line">}</div>
            <div class="line"> </div>
            <div class="line"># Choose as preferred...</div>
            <div class="line"> </div>
            <div class="line"># nvm install --lts</div>
            <div class="line"># nvm install node</div>
            <div class="line">$ nvm use system</div>
            <div class="line"> </div>
            <div class="line"># The useful &quot;cd_nvm()&quot; function is already provided in /etc/profile.d/bash_functions.sh - so, when navigating between Node project repo&#39;s on the command line, feel free to...</div>
            <div class="line"> </div>
            <div class="line">$ cd_nvm &lt;Node Project Repo&gt;</div>
            <div class="line"> </div>
            <div class="line"># ...and NVM should do it&#39;s thing.</div>
          </div>
          <!-- fragment -->
          <ul>
            <li>Fully ssh-authenticated Git and Chrome integration</li>
          </ul>
          <div class="fragment">
            <div class="line">get_chrome()</div>
            <div class="line">{</div>
            <div class="line">  local CHROME_KEY=&quot;/usr/share/keyrings/google-chrome.gpg&quot;</div>
            <div class="line"> </div>
            <div class="line">  curl &quot;https://dl.google.com/linux/direct/google-chrome-stable_current_$ARCH.deb&quot; -o &quot;/tmp/google-chrome.deb&quot;</div>
            <div class="line"> </div>
            <div class="line">  echo &quot;deb [arch=$ARCH signed-by=$CHROME_KEY] https://dl.google.com/linux/chrome/deb stable main&quot;</div>
            <div class="line"> </div>
            <div class="line">  apt install &quot;/tmp/google-chrome.deb&quot;</div>
            <div class="line"> </div>
            <div class="line">  local CHROME_TMP_KEY=&quot;/etc/apt/trusted.gpg.d/google-chrome.gpg&quot;</div>
            <div class="line"> </div>
            <div class="line">  cp -rvf $CHROME_TMP_KEY $CHROME_KEY</div>
            <div class="line"> </div>
            <div class="line">  rm -rvf $CHROME_TMP_KEY</div>
            <div class="line"> </div>
            <div class="line">  apt update</div>
            <div class="line">}</div>
            <div class="line"> </div>
            <div class="line">get_gith()</div>
            <div class="line">{</div>
            <div class="line">  local GH_KEY=&quot;$KEY_PATH/githubcli-archive-keyring.gpg&quot;</div>
            <div class="line"> </div>
            <div class="line">  curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | gpg --dearmor | tee $GH_KEY &gt;/dev/null</div>
            <div class="line"> </div>
            <div class="line">  echo &quot;deb [arch=$ARCH signed-by=$GH_KEY] https://cli.github.com/packages stable main&quot; | tee $APT_SOURCES/github-cli.list</div>
            <div class="line"> </div>
            <div class="line">  apt update</div>
            <div class="line"> </div>
            <div class="line">}</div>
            <div class="line"> </div>
            <div class="line"># Optionally install Chrome...*</div>
            <div class="line">$ get_chrome</div>
            <div class="line"> </div>
            <div class="line">$ get_gith</div>
            <div class="line"> </div>
            <div class="line"> </div>
            <div class="line"># * *Note that if you have w3m installed by now but not a full browser such as Chrome, the gh CLI can actually open and display the GitHub authentication webpage in ASCII format, directly in the Linux terminal, if it must ;)*</div>
          </div>
          <!-- fragment -->
          <p>
            Following the above, you can <code>exit</code> back to your user account, then
          </p>
          <div class="fragment">
            <div class="line">$ export PUBKEYPATH=&quot;$HOME/.ssh/id_ed25519.pub&quot;</div>
            <div class="line"> </div>
            <div class="line">$ alias g=&quot;git&quot;</div>
            <div class="line"> </div>
            <div class="line">$ sudo apt install gh</div>
            <div class="line">$ g config --global user.name &quot;&lt;Your Git Name&gt;&quot;</div>
            <div class="line">$ g config --global user.email &quot;&lt;Your Git Email&gt;&quot;</div>
            <div class="line">$ gh auth login</div>
            <div class="line"># Choose .ssh option... then;</div>
            <div class="line">$ gh auth setup-git</div>
            <div class="line"> </div>
            <div class="line">$ nano $XDG_CONFIG_HOME/git/config</div>
          </div>
          <!-- fragment -->
          <p>
            As nano shows, your Git SSH key credentials can now managed by the GitHub CLI client, and the GitHub CLI commands and credential manager tools are available to use, along with the regular Git and SSH commands. You can now invoke your SSH key (available at <code>$PUBKEYPATH</code>) with an expanded set of Git-based commands using SSH encryption;
          </p>
          <div class="fragment">
            <div class="line">$ export DEV_DIR=&quot;$HOME/Development&quot;</div>
            <div class="line"> </div>
            <div class="line">$ g clone git@github.com:StoneyDSP/ubento.git &quot;$DEV_DIR/UBento&quot;</div>
            <div class="line"> </div>
            <div class="line"># Or....</div>
            <div class="line"> </div>
            <div class="line">$ gh repo clone git@github.com:StoneyDSP/ubento.git &quot;$DEV_DIR/UBento&quot;</div>
          </div>
          <!-- fragment -->
          <p>
            Here are some other common tools for development - again, do <code>sudo -s</code>
            first (if you are running these commands directly from this <a class="el" href="d9/dd6/_r_e_a_d_m_e_8md.html">README.md</a> file);
          </p>
          <ul>
            <li>PostgreSQL &amp; PGAdmin (for PostgreSQL)</li>
          </ul>
          <div class="fragment">
            <div class="line">get_postgres()</div>
            <div class="line">{</div>
            <div class="line">  local PSQL_KEY=&quot;$KEY_PATH/apt.postgresql.org.gpg&quot;</div>
            <div class="line"> </div>
            <div class="line">  wget -O - &quot;https://www.postgresql.org/media/keys/ACCC4CF8.asc&quot; 2&gt;/dev/null | gpg --dearmor - | tee $PSQL_KEY &gt;/dev/null</div>
            <div class="line"> </div>
            <div class="line">  echo &quot;deb [arch=$ARCH signed-by=$PSQL_KEY] http://apt.postgresql.org/pub/repos/apt $DISTRO-pgdg main&quot; | tee $APT_SOURCES/pgdg.list</div>
            <div class="line"> </div>
            <div class="line">  apt update</div>
            <div class="line"> </div>
            <div class="line">  # apt install postgresql postgresql-contrib postgresql-client</div>
            <div class="line">}</div>
            <div class="line"> </div>
            <div class="line">get_pgadmin()</div>
            <div class="line">{</div>
            <div class="line">  local PGADMIN_KEY=&quot;$KEY_PATH/packages-pgadmin-org.gpg&quot;</div>
            <div class="line"> </div>
            <div class="line">  curl -fsSL &quot;https://www.pgadmin.org/static/packages_pgadmin_org.pub&quot; | gpg --dearmor -o $PGADMIN_KEY</div>
            <div class="line"> </div>
            <div class="line">  echo &quot;deb [arch=$ARCH signed-by=$PGADMIN_KEY] https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$DISTRO pgadmin4 main&quot; &gt; $APT_SOURCES/pgadmin4.list</div>
            <div class="line"> </div>
            <div class="line">  apt update</div>
            <div class="line">}</div>
            <div class="line"> </div>
            <div class="line"># install packages - the postgresql package will create a new user named &#39;postgres&#39;, as needed...</div>
            <div class="line">$ sudo apt install apache2 apache2-bin apache2-data apache2-utils apache2-doc postgresql postgresql-contrib postgresql-15-doc</div>
            <div class="line"> </div>
            <div class="line"># start the server...</div>
            <div class="line">$ sudo service postgresql start</div>
            <div class="line"> </div>
            <div class="line"># Install for both desktop and web modes:</div>
            <div class="line">$ sudo apt install pgadmin4</div>
            <div class="line"> </div>
            <div class="line"># set up pgAmdmin with your user email and password...</div>
            <div class="line">$ sudo /usr/pgadmin4/bin/setup-web.sh</div>
            <div class="line"> </div>
            <div class="line"># create a password, for example &#39;postgres&#39;...</div>
            <div class="line">$ sudo passwd postgres</div>
            <div class="line"> </div>
            <div class="line"># enter psql shell as user &#39;postgres&#39;...</div>
            <div class="line">$ sudo -u postgres psql</div>
            <div class="line"> </div>
            <div class="line"># in the psql shell, give &#39;postgres&#39; a password, list all users, create two more, and list again before exiting...</div>
            <div class="line">&gt; ALTER ROLE postgres WITH PASSWORD &#39;postgres&#39;;</div>
            <div class="line">&gt; \du</div>
            <div class="line">&gt; CREATE ROLE root CREATEDB CREATEROLE SUPERUSER LOGIN;</div>
            <div class="line">&gt; CREATE ROLE &lt;username&gt; CREATEDB CREATEROLE SUPERUSER LOGIN;</div>
            <div class="line">&gt; ALTER ROLE root WITH PASSWORD &#39;root&#39;;</div>
            <div class="line">&gt; ALTER ROLE &lt;username&gt; WITH PASSWORD &#39;&lt;password&gt;&#39;;</div>
            <div class="line">&gt; \du</div>
            <div class="line">&gt; \q</div>
            <div class="line"> </div>
            <div class="line"># open the link in a browser* to log in to pgAdmin (works on either Windows or Linux side);</div>
            <div class="line">http://localhost/pgadmin4</div>
            <div class="line"> </div>
            <div class="line"># Choose &#39;Register new server&#39;</div>
            <div class="line"># On &#39;General&#39; tab, choose any name you wish</div>
            <div class="line"># Go to &#39;connection&#39; tab and enter as follows;</div>
            <div class="line"> </div>
            <div class="line"># Hostname/address: localhost</div>
            <div class="line"># Port: 54322</div>
            <div class="line"># Maintenance database: postgres</div>
            <div class="line"># Username: postgres</div>
            <div class="line"># Password: postgres</div>
            <div class="line"> </div>
            <div class="line"># Click &#39;save&#39; - you should now see your local db&#39;s etc listed under &#39;servers&#39;!</div>
            <div class="line"> </div>
            <div class="line"># The above combination will also be served at;</div>
            <div class="line"> </div>
            <div class="line">postgresql://postgres:postgres@localhost:54322/postgres</div>
            <div class="line"> </div>
            <div class="line"># which is equivalent to;</div>
            <div class="line"> </div>
            <div class="line">{service}://{user}:{password}@{address}:{port}/{database}</div>
            <div class="line"> </div>
            <div class="line"># Note that some WSL users have reported better performance by using address value of &#39;127.0.0.1&#39; - I can&#39;t be too sure, but having your distro&#39;s hostname be renamed to something *other than* the Windows name tends to be helpful in these situations; I again suggest i.e., Windows host name = &quot;localclient&quot;, Linux host name = &quot;localhost&quot;. It throws a small warning in the WSL debug terminal on launch, but the operation is still allowed to pass.</div>
            <div class="line"> </div>
            <div class="line"># Now your user(s) can also use the full PostgresQL (and PGAdmin) tools on the CL... without invoking &#39;sudo&#39;.</div>
            <div class="line"># Postgres also has some well-used bash completion scripts such as &#39;createdb&#39;. Make sure to generate the bash completion scripts!</div>
            <div class="line"># *note that that you can also launch the &#39;pgAdmin4-desktop&#39; app instead of the web-based interface, if you prefer...</div>
          </div>
          <!-- fragment -->
          <ul>
            <li>Supabase (check repo for latest release version number, these outdate quickly...)</li>
          </ul>
          <div class="fragment">
            <div class="line">$ export SYS_SUPABASE_V=&quot;1.27.0&quot;</div>
            <div class="line"> </div>
            <div class="line">$ get_supabase()</div>
            <div class="line">{</div>
            <div class="line">    curl &quot;https://github.com/supabase/cli/releases/download/v$SYS_SUPABASE_V/supabase_$SYS_SUPABASE_V_linux_$ARCH.deb&quot; -o &quot;$XDG_DOWNLOAD_DIR/supabase.deb&quot;</div>
            <div class="line"> </div>
            <div class="line">    apt install &quot;$XDG_DOWNLOAD_DIR/supabase_$SYS_SUPABASE_V_linux_$ARCH.deb&quot;</div>
            <div class="line"> </div>
            <div class="line">    supabase completion bash &gt; /etc/bash_completion.d/supabase</div>
            <div class="line">}</div>
            <div class="line"> </div>
            <div class="line">$ get_supabase</div>
            <div class="line"> </div>
            <div class="line"># as user...</div>
            <div class="line">$ supabase login</div>
          </div>
          <!-- fragment -->
          <ul>
            <li>Postman (will save your login key to your home folder)</li>
          </ul>
          <div class="fragment">
            <div class="line">&amp; get_postman()</div>
            <div class="line">{</div>
            <div class="line">    curl -o- &quot;https://dl-cli.pstmn.io/install/linux64.sh&quot; | bash</div>
            <div class="line">}</div>
            <div class="line"> </div>
            <div class="line"># as user...</div>
            <div class="line">$ postman login</div>
          </div>
          <!-- fragment -->
          <ul>
            <li>CMake (you should have Make and/or other build tools, and check out Visual Studio with WSL - you can now use MSBuild tools on Linux-side code!)</li>
          </ul>
          <div class="fragment">
            <div class="line">get_cmake()</div>
            <div class="line">{</div>
            <div class="line">  local KITWARE_KEY=&quot;$KEY_PATH/kitware-archive-keyring.gpg&quot;</div>
            <div class="line"> </div>
            <div class="line">  wget -O - &quot;https://apt.kitware.com/keys/kitware-archive-latest.asc&quot; 2&gt;/dev/null | gpg --dearmor - | tee $KITWARE_KEY &gt;/dev/null</div>
            <div class="line"> </div>
            <div class="line">  echo &quot;deb [arch=$ARCH signed-by=$KITWARE_KEY] https://apt.kitware.com/ubuntu $DISTRO main&quot; | tee $APT_SOURCES/kitware.list</div>
            <div class="line"> </div>
            <div class="line">  apt update</div>
            <div class="line"> </div>
            <div class="line">  # sudo apt install kitware-archive-keyring cmake cmake-data cmake-doc ninja-build</div>
            <div class="line">}</div>
            <div class="line"> </div>
            <div class="line">$ apt install kitware-archive-keyring cmake cmake-data cmake-doc ninja-build</div>
            <div class="line">$ cmake completion bash &gt; /etc/bash_completion.d/cmake # not sure of the actual correct command here, check cmake docs to confirm...</div>
          </div>
          <!-- fragment -->
          <ul>
            <li>vcpkg-tool (still working on this, note that you can get vcpkg itself quite easily too)</li>
          </ul>
          <div class="fragment">
            <div class="line">$ get_vcpkg_tool()</div>
            <div class="line">{</div>
            <div class="line">    . &lt;(curl https://aka.ms/vcpkg-init.sh -L)</div>
            <div class="line"> </div>
            <div class="line">    . ~/.vcpkg/vcpkg-init</div>
            <div class="line"> </div>
            <div class="line">    vcpkg integrate install</div>
            <div class="line"> </div>
            <div class="line">    vcpkg integrate bash</div>
            <div class="line"> </div>
            <div class="line">    vcpkg completion bash &gt; /etc/bash_completion.d/vcpkg</div>
            <div class="line">}</div>
          </div>
          <!-- fragment -->
          <p>
            Untested; integrating <code>pkg-config</code>
            to detect <code>.pc</code> files stored on either system... check the following (and my CMake repo);
          </p>
          <div class="fragment">
            <div class="line">$ pkgconfig --list-all</div>
          </div>
          <!-- fragment -->
          <h2>
            <a class="anchor" id="autotoc_md14"></a>
            [INTEROPERABILITY]</h2>
          <ul>
            <li>
              We can set Linux-side aliases to our Windows executables in <code>/etc/profile.d/bash_aliases.sh</code> like this;
            </li>
          </ul>
          <div class="fragment">
            <div class="line">alias wsl=&#39;/mnt/c/Windows/System32/wsl.exe&#39;</div>
            <div class="line"> </div>
            <div class="line">$ wsl --list --verbose</div>
            <div class="line"># Will list all of WSL&#39;s installed distros and statuses</div>
            <div class="line"> </div>
            <div class="line">alias notepad=&#39;/mnt/c/Windows/System32/notepad.exe&#39;</div>
            <div class="line"> </div>
            <div class="line">$ notepad .</div>
            <div class="line"># Will launch Notepad - careful with those line ending settings!</div>
          </div>
          <!-- fragment -->
          <ul>
            <li>What about using our Linux-side libs and binaries on our Windows-side files, in PowerShell? Well...</li>
          </ul>
          <p>Let's call the WSL Ubento user-login shell with a command line invocation, to create and open a new Windows-local file named 'nanotest';</p>
          <div class="fragment">
            <div class="line">&gt; wsl --shell-type login -d ubento --exec nano ./nanotest</div>
          </div>
          <!-- fragment -->
          <p>Type the word 'success!' and press 'Ctrl-s', then 'Ctrl-x', to save and exit nano, then execute the below in PowerShell to 'cat' the result;</p>
          <div class="fragment">
            <div class="line">&gt; wsl --shell-type login -d ubento --exec cat ./nanotest</div>
            <div class="line"># success!</div>
          </div>
          <!-- fragment -->
          <p>
            Be very wary of file permissions, line-ending settings, and conversions that the above basic text editors are unknowingly capable of, and leverage every interoperability opportunity that you can find among their individual configuration files. For example, GNU nano uses a 'nanorc' or '*.nanorc' file to control certain configuration aspects, handily on a per-filetype basis. Some 'nanorc' settings to be very watchful of (suggested settings below) - this file usually exists at system-level in <code>/etc/nanorc</code>
            and user-level in <code>$XDG_CONFIG_HOME/nano/nanorc</code>;
          </p>
          <div class="fragment">
            <div class="line">## Don&#39;t convert files from DOS/Mac format.</div>
            <div class="line">set noconvert</div>
            <div class="line">## Save files by default in Unix format (also when they were DOS or Mac).</div>
            <div class="line"># set unix</div>
          </div>
          <!-- fragment -->
          <ul>
            <li>Don't forget to test out VSCode with the Remote Development extension installed on the Windows side, of course... ;</li>
          </ul>
          <p>This is an excellent example of WSL capable is offering; your code-base is stored and served from "localhost", i.e., the Linux (back-end) side, while the VS Code graphical code-editor application runs in "localclient", i.e., your Windows-side software and hardware</p>
          <div class="fragment">
            <div class="line">$ cd $HOME</div>
            <div class="line">$ code .</div>
            <div class="line"> </div>
            <div class="line"># Will run an installation step for &#39;vscode-server-remote&#39; on first run....</div>
            <div class="line"># Also check the &#39;extensions&#39; tab for many WSL-based versions of your favourite extensions</div>
            <div class="line"> </div>
            <div class="line"> </div>
            <div class="line"># You can also use your Windows-side VSCode, via the remote WSL extension, as one of your preferred default editors in ubento;</div>
          </div>
          <!-- fragment -->
          <ul>
            <li>Test Docker Desktop interoperability, if you have it; (IMPORTANT - do not run this step until AFTER creating your user with UID 1000, otherwise Docker tries to steal this UID!);</li>
          </ul>
          <div class="fragment">
            <div class="line"># make sure the &#39;UBento&#39; option is checked in Windows Docker Desktop settings &gt; resources for this to work</div>
            <div class="line"> </div>
            <div class="line">$ docker run hello-world</div>
            <div class="line">$ docker run -it alpine bash</div>
          </div>
          <!-- fragment -->
          <p>
            <img src="https://raw.githubusercontent.com/StoneyDSP/ubento/main/ubento.png" alt="UBento-icon" class="inline">
          </p>
          <h2>
            <a class="anchor" id="autotoc_md15"></a>
            [TROUBLESHOOTING]</h2>
          <h2>
            <a class="anchor" id="autotoc_md16"></a>
            Enabling Hyper-V, Virtual Machine Platform, and WSL on Windows.</h2>
          <ul>
            <li>Get the required packages (save as "HyperV.bat" and launch in PowerShell):</li>
          </ul>
          <div class="fragment">
            <div class="line">pushd &quot;%~dp0&quot;</div>
            <div class="line"> </div>
            <div class="line">dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hv.txt</div>
            <div class="line"> </div>
            <div class="line">for /f %%i in (&#39;findstr /i . hv.txt 2^&gt;nul&#39;) do dism /online /norestart /add-package:&quot;%SystemRoot%\servicing\Packages\%%i&quot;</div>
            <div class="line"> </div>
            <div class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V -All /LimitAccess /ALL</div>
            <div class="line"> </div>
            <div class="line">pause</div>
          </div>
          <!-- fragment -->
          <p>Restart your Windows machine once the above is complete.</p>
          <ul>
            <li>Enable the Windows features (run each command in PowerShell):</li>
          </ul>
          <p>Virtual Machine Platform;</p>
          <div class="fragment">
            <div class="line">&gt; dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</div>
          </div>
          <!-- fragment -->
          <p>Hyper Virtualization;</p>
          <div class="fragment">
            <div class="line">&gt; dism.exe /online /enable-feature /featurename:Microsoft-Hyper-V /all /limitaccess /all /norestart</div>
          </div>
          <!-- fragment -->
          <p>Windows Subsystem for Linux;</p>
          <div class="fragment">
            <div class="line">&gt; dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</div>
          </div>
          <!-- fragment -->
          <p>Restart your Windows machine once the above is complete.</p>
          <h2>
            <a class="anchor" id="autotoc_md17"></a>
            Storage considerations</h2>
          <p>Think very carefully about how/where you choose to store your runtime distro on disk, and linkages between environments - particularly the user desktop, downloads, documents folders, and other regularly accessed locations.</p>
          <p>
            It is generally safe to have access to your Windows-side file system via the Linux-side <code>/mnt</code>
            directory <em>and</em>
            to use symbolic links from Linux-side (user's "download" folders, etc) to the Windows environment. However, based on some experience, I would recommend <em>against</em> combining this with running your distro from an external/removable storage drive, like USB or SD card.
          </p>
          <p>
            While the mounting/linkage practices are both quite safe enough to be default behaviour in WSL, <em>and</em> it mounts and runs just fine from external storage which I happily depend upon daily, you could be running some risk when attempting to write to your Windows file system from the Linux-side and experiencing a hardware failure, such as a cat chewing on your USB stick and causing some file-corruption.
          </p>
          <p>
            Desktop linkage is really cool, as is external storage - but I'd have to recommend <em>not</em> to mix the two, in the case of WSL.
          </p>
          <h2>
            <a class="anchor" id="autotoc_md18"></a>
            Still having package/service dependency issues?</h2>
          <p>
            The MS Store Ubuntu distro ships with a very large APT package suite named <code>ubuntu-wsl</code>
            that we can instead break down into smaller dependency cycles, as and where (or even if) required. But you can go ahead and <code>apt install ubtuntu-wsl</code> if you do experience any issues.
          </p>
          <div class="fragment">
            <div class="line">sudo apt install ubuntu-wsl</div>
          </div>
          <!-- fragment -->
          <p>
            Note that the package <code>wsl-setup</code> attempts to run the Ubiquity "install-RELEASE" snap that creates the default WSL Ubuntu install for us, should you be interested (requires apt install snapd).
          </p>
          <div class="fragment">
            <div class="line">sudo apt install snapd</div>
            <div class="line">sudo snap refresh</div>
            <div class="line">sudo snap list</div>
          </div>
          <!-- fragment -->
          <p>
            No default snaps (cool!), but all the <code>/snapd/bin</code>
            folder locations should be appended to the $PATH variable - make sure to check <code>/etc/profile</code> and the troubleshooting tips below :)
          </p>
          <p>To get back to the MS Store version from here, you can</p>
          <div class="fragment">
            <div class="line">sudo snap install ubuntu-desktop-installer --classic</div>
            <div class="line">sudo wsl-setup</div>
          </div>
          <!-- fragment -->
          <h2>
            <a class="anchor" id="autotoc_md19"></a>
            Defining Runtime Behaviour</h2>
          <p>This step need not apply if you are happy running Linux GUI apps (with excellent performance) but aren't looking to explore the desktop capabilities of your distro. GUI apps will already be working smoothly at this stage, directly from their Windows launchers. But if you're doing anything that requires systemd to be installed, then it is quite important provide some control over certain system-level runtime behaviours; particularly, for our user's first launch into systemd.</p>
          <div class="fragment">
            <div class="line">$ echo -e &quot;[boot]\n systemd=true\n&quot; &gt;&gt; /etc/wsl.conf</div>
          </div>
          <!-- fragment -->
          <p>
            Make sure the following two modified functions from the x410 cookbook are defined in <code>/etc/profile.d/ubento_helpers.sh</code>
            and are present/called in <code>$HOME/.profile</code>
            for user, but <em>NOT</em> for root (IMPORTANT!) - they should be at the end after the exports;
          </p>
          <div class="fragment">
            <div class="line">set_runtime_dir</div>
            <div class="line">set_session_bus</div>
            <div class="line"> </div>
            <div class="line"># https://x410.dev/cookbook/wsl/running-ubuntu-desktop-in-wsl2/</div>
          </div>
          <!-- fragment -->
          <p>Setup systemd/dbus and accessibility bus, do a full shutdown;</p>
          <div class="fragment">
            <div class="line">$ apt install systemd dbus at-spi2-core</div>
            <div class="line">$ wsl.exe -d UBento --shutdown</div>
          </div>
          <!-- fragment -->
          <p>It is CRITICAL* during systemd configuration that of the previous steps, the following (as a minimum) are taken in the correct order, as summarized;</p>
          <ul>
            <li>launch distro as root to install apt-utils, dialog, and sudo</li>
            <li>copy ubuntu-helpers/profile/bashrc/wsl.conf files</li>
            <li>add new user and password</li>
            <li>install systemd/dbus/at-spi2-core</li>
            <li>shutdown distro and reboot as new user</li>
          </ul>
          <p>
            *this sequence ensures that when the distro default user account is finally accessed, it has the UID of 1000 assigned, and calls the <code>set_runtime_dir</code>
            and <code>set_session_bus</code>
            functions from the X410 cookbook using this UID during initialization. This sequence creates a runtime directory at <code>/run/user/1000</code>
            during initialization where the dbus-daemon (and accessibility bus) is started from, and this runtime location is maintained/used when opening further sessions using this same distro. It is also critical that the root user does NOT have access to these functions (they should not be present at all in <code>/root/.profile</code>).
          </p>
          <h2>
            <a class="anchor" id="autotoc_md20"></a>
            Help! My distro is broken ('read-only' file system errors)</h2>
          <p>If you are unable to load your distro and recieve errors such as the above...</p>
          <ul>
            <li>DON'T use anything except NFTS as your storage volume type - in particular, FAT32 file systems do NOT allow file sizes above 4gb. Your distro will fail on a FAT32 storage drive once it reaches 4gb - simply move the file to a backup location, re-format the storage to NTFS and try again.</li>
            <li>Enable the 'debug' option in your C:\Users\{username}.wslconfig file to launch an additional terminal read-out to gather more info on the issue, it's usually one of two things...</li>
            <li>Make sure that the storage location of your distro's ext4.vhd is not full, i.e., if using external/remote storage</li>
            <li>
              If it appears that you are very low on disk space, do <code>$ ls -la /var/log</code>
              - you may find a few thousand mb's worth of log files, particularly from the X server (tip welcome!), which you can <code>$ sudo rm -rvf /var/log/Xorg*</code> to remove entirely.
            </li>
            <li>
              If disk space continues to be the issue (i.e, the above command appears to have worked, but your ext4.vhdx didn't actually shrink so you are still out of disk space), then you are probably using .vhdx (i.e., 'dynamic' sized virtual disk) where plain old .vhd (i.e., 'static' sized virtual disk) would have done the trick... you can use WSL as a handy and easy .vhd/x conversion tool with <code>wsl --export &lt;distro&gt; 'C:\some\storage\location\ext4.vhd' --vhd</code>
              and <code>wsl --import-in-place &lt;distro&gt; 'C:\some\storage\location\ext4.vhd' --vhd</code> in a matter of seconds. See [TIPS]:Storage for more.
            </li>
            <li>If it does not appear to be a disk space issue but rather some strange permissions error... there are a few reasons why this can happen, which can often easily be fixed using the below (which even works on the 'permission-error' distro itself);</li>
          </ul>
          <div class="fragment">
            <div class="line">## In PowerShell, we will first unmount the .vhd then re-import it to ensure the correct mount location is given (as it can get corrupted from time to time);</div>
            <div class="line">&gt; wsl -d &lt;distro&gt; --unmount</div>
            <div class="line">&gt; wsl --import-in-place &lt;distro&gt; &#39;C:\my\install\location\ext4.vhdx&#39; # Or .vhdx, or even .tar...</div>
            <div class="line">&gt; wsl --shutdown # Wait until wsl -l -v shows all distros totally offline</div>
            <div class="line">&gt; wsl -d &lt;distro&gt;</div>
            <div class="line"> </div>
            <div class="line">## Now in your distro;</div>
            <div class="line">$ init_permissions()</div>
            <div class="line">{</div>
            <div class="line">    chmod 755 / &amp;&amp; \</div>
            <div class="line">    chmod 1777 /tmp &amp;&amp;\</div>
            <div class="line">    find /tmp \</div>
            <div class="line">        -mindepth 1 \</div>
            <div class="line">        -name &#39;.*-unix&#39; -exec chmod 1777 {} + -prune -o \</div>
            <div class="line">        -exec chmod go-rwx {} +</div>
            <div class="line"> </div>
            <div class="line">    # https://unix.stackexchange.com/questions/71622/what-are-correct-permissions-for-tmp-i-unintentionally-set-it-all-public-recu</div>
            <div class="line">}</div>
            <div class="line">$ init_permissions</div>
            <div class="line">$ mount | grep ext4</div>
            <div class="line">## Note which entry contains &quot;/&quot; exclusively - should probably be under &quot;sdc&quot;, but sometimes will be &quot;sdd&quot; or something else (usuaully when broken)...</div>
            <div class="line">$ sudo e2fsck /dev/sdc -y # Use /sdd or whichever entry as per the previous command!</div>
          </div>
          <!-- fragment -->
          <p>
            The final command above may take a while - in fact, it sometimes seems to be need to be run twice - and it's likely wise to <code>wsl --shutdown</code> between attempts. However, all of the above steps have revived a seemingly-dead distro for me ever since discovering them, whereas I once was faced with simply deleting and starting again on any error which was of course heavily disheartening.
          </p>
          <p>Thus, I firmly recommend examing the above suggestions in the case of a seemingly "broken" distro - it does seem that the fixes are usually just a few terminal commands and nothing more.</p>
          <h2>
            <a class="anchor" id="autotoc_md21"></a>
            [TIPS]</h2>
          <h2>
            <a class="anchor" id="autotoc_md22"></a>
            Buidling from source</h2>
          <p>(tbc - could just place a bash script and use curl/wget/git to fetch everything... alternatively, check the pre-releases tab for a pre-build!)</p>
          <div class="fragment">
            <div class="line">&gt; docker run -it ubuntu bash ls /</div>
            <div class="line">&gt; docker export -o &quot;C:\Users\${username}\ubuntu.tar&quot;  ${distronumber}</div>
            <div class="line">&gt; wsl --import UBento &quot;C:\Users\${username}\UBento&quot; &quot;C:\Users\${username}\ubuntu.tar&quot;</div>
            <div class="line">&gt; wsl -d Ubento</div>
            <div class="line"> </div>
            <div class="line">$ init_permissions()</div>
            <div class="line">{</div>
            <div class="line">    chmod 755 / &amp;&amp; \</div>
            <div class="line">    chmod 1777 /tmp &amp;&amp;\</div>
            <div class="line">    find /tmp \</div>
            <div class="line">        -mindepth 1 \</div>
            <div class="line">        -name &#39;.*-unix&#39; -exec chmod 1777 {} + -prune -o \</div>
            <div class="line">        -exec chmod go-rwx {} +</div>
            <div class="line"> </div>
            <div class="line">    # https://unix.stackexchange.com/questions/71622/what-are-correct-permissions-for-tmp-i-unintentionally-set-it-all-public-recu</div>
            <div class="line">}</div>
            <div class="line">$ export -f init_permissions</div>
            <div class="line"> </div>
            <div class="line">$ init_permissions</div>
            <div class="line">$ apt update</div>
            <div class="line">$ apt install apt-utils dialog &amp;&amp; apt install sudo &amp;&amp; sudo -s</div>
            <div class="line">$ sudo unminimize</div>
            <div class="line">$ apt install nano less lsb-release curl wget git # And whatever other dependencies you might need...</div>
          </div>
          <!-- fragment -->
          <p>Git-clone the UBento source files somewhere locally... you could store it Linux-side directory, such as '$HOME/Development/ubento' and adjust this step accordingly. See the [TIPS] and [DEVTOOLS KEYRING] sections for ideas.</p>
          <p>Here's an example where we've git cloned this repo it to our Windows home folder;</p>
          <div class="fragment">
            <div class="line">$ export UBENTO_WIN_REPO=&quot;/mnt/c/Users/${username}/repos/ubento&quot;</div>
            <div class="line"> </div>
            <div class="line">$ git clone &quot;https://github.com/StoneyDSP/ubento.git&quot; &quot;$UBENTO_WIN_REPO&quot;</div>
            <div class="line"> </div>
            <div class="line">$ yes | cp -f &quot;$UBENTO_WIN_REPO/etc/profile.d/*.sh&quot;              &quot;/etc/profile.d/*.sh&quot;              &amp;&amp; \</div>
            <div class="line">yes | cp -f &quot;$UBENTO_WIN_REPO/etc/skel/.bash_profile&quot;            &quot;/etc/skel/.bash_profile&quot;          &amp;&amp; \</div>
            <div class="line">yes | cp -f &quot;$UBENTO_WIN_REPO/etc/skel/.bash_logout&quot;             &quot;/etc/skel/.bash_logout&quot;           &amp;&amp; \</div>
            <div class="line">yes | cp -f &quot;$UBENTO_WIN_REPO/etc/skel/.bashrc&quot;                  &quot;/etc/skel/.bashrc&quot;                &amp;&amp; \</div>
            <div class="line">yes | cp -f &quot;$UBENTO_WIN_REPO/etc/bash.bashrc&quot;                   &quot;/etc/bash.bashrc&quot;                 &amp;&amp; \</div>
            <div class="line">yes | cp -f &quot;$UBENTO_WIN_REPO/etc/profile&quot;                       &quot;/etc/profile&quot;                     &amp;&amp; \</div>
            <div class="line">yes | cp -f &quot;$UBENTO_WIN_REPO/etc/environment&quot;                   &quot;/etc/environment&quot;                 &amp;&amp; \</div>
            <div class="line">yes | cp -f &quot;$UBENTO_WIN_REPO/root/.bashrc&quot;                      &quot;/root/.bashrc&quot;                    &amp;&amp; \</div>
            <div class="line">yes | cp -f &quot;$UBENTO_WIN_REPO/root/.bash_profile&quot;                &quot;/root/.bash_profile&quot;</div>
            <div class="line"># ...and so forth (will executable-script this operation at some point!)</div>
            <div class="line"> </div>
            <div class="line"># *optional, see final post-install step</div>
            <div class="line">$ yes | cp -f &quot;$UBENTO_WIN_REPO/etc/wsl.conf&quot; &quot;/etc/wsl.conf&quot;</div>
          </div>
          <!-- fragment -->
          <p>
            Note that we don't go making and copying stuff into <code>/home/{username}</code>
            at all, since we didn't create a user yet - instead, we place all of our desired user-level config files in <code>/etc/skel</code>
            , then run an <code>adduser</code>
            - style command to securely create a new system user, with all the correct file permissions and user specs (UID = 1000, for example) taken care of, which is itself populated by the contents of <code>/etc/skel</code>.
          </p>
          <p>To do that, we can;</p>
          <div class="fragment">
            <div class="line">$ export username=&quot;&lt;Your User Name&gt;&quot;</div>
            <div class="line">$ export fullname=&quot;&lt;Your Full Name&gt;&quot;</div>
            <div class="line"> </div>
            <div class="line">$ make_user()</div>
            <div class="line">{</div>
            <div class="line">    adduser --home=/home/&quot;${1}&quot; --shell=/bin/bash --gecos=&quot;${2}&quot; --uid=1000 &quot;${1}&quot;</div>
            <div class="line"> </div>
            <div class="line">    usermod --group=adm,dialout,cdrom,floppy,tape,sudo,audio,dip,video,plugdev &quot;${1}&quot;</div>
            <div class="line"> </div>
            <div class="line">    echo -e &quot;[user]\n default=${1}\n&quot; &gt;&gt; /etc/wsl.conf</div>
            <div class="line"> </div>
            <div class="line">    login ${1}</div>
            <div class="line">}</div>
            <div class="line"> </div>
            <div class="line">$ make_user &quot;${username}&quot; &quot;${fullname}&quot;</div>
          </div>
          <!-- fragment -->
          <h2>
            <a class="anchor" id="autotoc_md23"></a>
            [DESKTOP SETTINGS]</h2>
          <p>
            Now we can make ourselves at home in the <code>$HOME</code> folder.
          </p>
          <p>
            The user-local <code>$HOME/.bash_profile</code>
            file will contain several pointers for our desktop environment, including additional bin and man paths, as well as linkage to our home folders - we don't need to set these ourselves as they will have been pulled in from <code>/etc/skel</code> when we created our user (see previous steps!), but these are useful to be aware of when setting up our desktop;
          </p>
          <div class="fragment">
            <div class="line">if [ -d &quot;$HOME/bin&quot; ] ; then</div>
            <div class="line">    PATH=&quot;$HOME/bin:$PATH&quot;</div>
            <div class="line">fi</div>
            <div class="line"> </div>
            <div class="line">if [ -d &quot;$HOME/.local/bin&quot; ] ; then</div>
            <div class="line">    PATH=&quot;$HOME/.local/bin:$PATH&quot;</div>
            <div class="line">fi</div>
            <div class="line"> </div>
            <div class="line">if [ -d &quot;$HOME/man&quot; ]; then</div>
            <div class="line">    MANPATH=&quot;$HOME/man:$MANPATH&quot;</div>
            <div class="line">fi</div>
            <div class="line"> </div>
            <div class="line">if [ -d &quot;$HOME/info&quot; ]; then</div>
            <div class="line">    INFOPATH=&quot;$HOME/info:$INFOPATH&quot;</div>
            <div class="line">fi</div>
            <div class="line"> </div>
            <div class="line">export PATH MANPATH INFOPATH</div>
            <div class="line"> </div>
            <div class="line">if [ -z &quot;$XDG_CONFIG_HOME&quot; ]; then</div>
            <div class="line">    export XDG_CONFIG_HOME=&quot;$HOME/.config&quot;</div>
            <div class="line">fi</div>
            <div class="line"> </div>
            <div class="line">if [ -z &quot;$XDG_CACHE_HOME&quot; ]; then</div>
            <div class="line">    export XDG_CACHE_HOME=&quot;$HOME/.cache&quot;</div>
            <div class="line">fi</div>
            <div class="line"> </div>
            <div class="line">if [ -z &quot;$XDG_DATA_HOME&quot; ]; then</div>
            <div class="line">    export XDG_DATA_HOME=&quot;$HOME/.local/share&quot;</div>
            <div class="line">fi</div>
            <div class="line"> </div>
            <div class="line">if [ -z &quot;$XDG_STATE_HOME&quot; ]; then</div>
            <div class="line">    export XDG_STATE_HOME=&quot;$HOME/.local/state&quot;</div>
            <div class="line">fi</div>
            <div class="line"> </div>
            <div class="line">export XDG_DESKTOP_DIR=&quot;$HOME/Desktop&quot;</div>
            <div class="line">export XDG_DOCUMENTS_DIR=&quot;$HOME/Documents&quot;</div>
            <div class="line">export XDG_DOWNLOAD_DIR=&quot;$HOME/Downloads&quot;</div>
            <div class="line">export XDG_MUSIC_DIR=&quot;$HOME/Music&quot;</div>
            <div class="line">export XDG_TEMPLATES_DIR=&quot;$HOME/Templates&quot;</div>
            <div class="line">export XDG_PICTURES_DIR=&quot;$HOME/Pictures&quot;</div>
            <div class="line">export XDG_PUBLICSHARE_DIR=&quot;$HOME/Public&quot;</div>
            <div class="line">export XDG_VIDEOS_DIR=&quot;$HOME/Videos&quot;</div>
            <div class="line"> </div>
            <div class="line"># And so forth...</div>
          </div>
          <!-- fragment -->
          <p>
            The directories indicated in all of the above <em>should</em> exist in some form, for a working desktop. One excellent touch is to leverage Linux symbolic links to share your user folders between Windows and Linux environments (option 1), or we can create ourselves an alternative userspace by not going outside the distro (option 2).
          </p>
          <p>By providing symbolic links to our Windows user folders, we can get some huge benefits such as a shared "Downloads" folder and a fully "Public"-ly shared folder. Thus, you can download a file in your Windows internet browser, and instantly access it from your WSL user's downloads folder (which is the exact same file address), for example. However, there is some risk in mixing certain file types between Windows and WSL - there are several articles on the web on the subject (to be linked) which you should probably read before proceeding with either, or a mix, of the following;</p>
          <h2>
            <a class="anchor" id="autotoc_md24"></a>
            option 1 - linked storage;</h2>
          <p>Symlink your Windows and UBento user folders with these commands (change the respective usernames if yours don't match);</p>
          <ul>
            <li>
              <p class="startli">Logged in as user, NOT root(!);</p>
              <div class="fragment">
                <div class="line">$ ln -s &quot;/mnt/c/Users/${username}/Desktop&quot;    &quot;/home/${username}/Desktop&quot;   &amp;&amp; \</div>
                <div class="line">ln -s &quot;/mnt/c/Users/${username}/Documents&quot;    &quot;/home/${username}/Documents&quot; &amp;&amp; \</div>
                <div class="line">ln -s &quot;/mnt/c/Users/${username}/Downloads&quot;    &quot;/home/${username}/Downloads&quot; &amp;&amp; \</div>
                <div class="line">ln -s &quot;/mnt/c/Users/${username}/Music&quot;        &quot;/home/${username}/Music&quot;     &amp;&amp; \</div>
                <div class="line">ln -s &quot;/mnt/c/Users/${username}/Pictures&quot;     &quot;/home/${username}/Pictures&quot;  &amp;&amp; \</div>
                <div class="line">ln -s &quot;/mnt/c/Users/${username}/Templates&quot;    &quot;/home/${username}/Templates&quot; &amp;&amp; \</div>
                <div class="line">ln -s &quot;/mnt/c/Users/${username}/Videos&quot;       &quot;/home/${username}/Videos&quot;</div>
              </div>
              <!-- fragment -->
            </li>
            <li>
              <p class="startli">optional - logged in as root;</p>
              <div class="fragment">
                <div class="line">$ ln -s &quot;/mnt/c/Users/Administrator/Desktop&quot; &quot;/root/Desktop&quot;</div>
                <div class="line">...</div>
                <div class="line">$ ln -s &quot;/mnt/c/Users/Administrator/Videos&quot; &quot;/root/Videos&quot;</div>
              </div>
              <!-- fragment -->
            </li>
            <li>
              <p class="startli">optional - 'public' shared folder...</p>
              <div class="fragment">
                <div class="line">$ ln -s &quot;/mnt/c/Users/Public&quot; &quot;/home/${username}/Public&quot;</div>
                <div class="line">$ ln -s &quot;/mnt/c/Users/Public&quot; &quot;/root/Public&quot;</div>
              </div>
              <!-- fragment -->
            </li>
            <li>
              <p class="startli">Alternatively, make a function;</p>
              <div class="fragment">
                <div class="line">$ link_home_dirs()</div>
                <div class="line">{</div>
                <div class="line">    ln -s /mnt/c/Users/${1}/${2} $HOME/${2}</div>
                <div class="line">}</div>
                <div class="line"> </div>
                <div class="line">$ link_home_dirs &quot;&lt;Windows User Name&gt;&quot; &quot;Downloads&quot;</div>
                <div class="line"># ...etc</div>
              </div>
              <!-- fragment -->
            </li>
          </ul>
          <p>Let's expand our $XDG_DOWNLOAD_DIR variable out... </p>
<pre class="fragment">```
		# (this is NOT a terminal command!!!)
		XDG_DOWNLOAD_DIR = "$HOME/Downloads" = "/home/${username}/Downloads = /mnt/c/${username}/Downloads"
		```
		</pre>
          <p> The exact same directory (and it's contents) on the Windows side... </p>
<pre class="fragment">```
		# (this is NOT a terminal command!!!)
		"$HOME\Downloads" = "C:\Users\${username}\Downloads" = "\\wsl.localhost\UBento\home\${username}\Downloads"
		```
		</pre>
          <p> All of the above are one and the same directory...! Storage is on the Windows-side hard drive; the distro simply symlinks the user to the same filesystem address.</p>
          <h2>
            <a class="anchor" id="autotoc_md25"></a>
            option 2 - local storage; create new UBento user folders with these commands;</h2>
          <ul>
            <li>
              <p class="startli">Run this once as the user, then once as root...</p>
              <div class="fragment">
                <div class="line">$ mkdir \</div>
                <div class="line">$HOME/Desktop \</div>
                <div class="line">$HOME/Documents \</div>
                <div class="line">$HOME/Downloads \</div>
                <div class="line">$HOME/Music \</div>
                <div class="line">$HOME/Pictures \</div>
                <div class="line">$HOME/Public \</div>
                <div class="line">$HOME/Templates \</div>
                <div class="line">$HOME/Videos</div>
              </div>
              <!-- fragment -->
            </li>
            <li>
              <p class="startli">Alternatively, use the handy XDG package to do it for us;</p>
              <div class="fragment">
                <div class="line">$ sudo apt install xdg-user-dirs</div>
                <div class="line">$ xdg-user-dirs-defaults</div>
              </div>
              <!-- fragment -->
            </li>
          </ul>
          <p>With this option, no linkage is created to your Windows user folders or hard disk; all storage remains local to your distro's portable vhd, wherever you chose to store it.</p>
          <p>
            We're using <code>$XDG_CONFIG_HOME</code>
            = <code>$HOME/.config</code>
            for our desktop configuration folder (you may have to <code>mkdir $HOME/.config</code> if it's not already present). There are some useful things we should set up in here.
          </p>
          <h2>
            <a class="anchor" id="autotoc_md26"></a>
            We can set bookmark tabs for our chosen Linux-side desktop explorer;</h2>
          <div class="fragment">
            <div class="line">$ nano $HOME/.config/gtk-3.0/bookmarks</div>
          </div>
          <!-- fragment -->
          <p>add the following (with the correct username):</p>
          <div class="fragment">
            <div class="line">file:///home/${username}/Desktop</div>
            <div class="line">file:///home/${username}/Documents</div>
            <div class="line">file:///home/${username}/Downloads</div>
            <div class="line">file:///home/${username}/Music</div>
            <div class="line">file:///home/${username}/Pictures</div>
            <div class="line">file:///home/${username}/Videos</div>
          </div>
          <!-- fragment -->
          <p>These locations will now appear in the tab bar of your Linux-side desktop explorer, as they should.</p>
          <h2>
            <a class="anchor" id="autotoc_md27"></a>
            We can also connect our Linux-side desktop explorer to remote servers;</h2>
          <div class="fragment">
            <div class="line">$ nano $HOME/.config/gtk-3.0/servers</div>
          </div>
          <!-- fragment -->
          <p>add the following:</p>
          <div class="fragment">
            <div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div>
            <div class="line">&lt;xbel version=&quot;1.0&quot;</div>
            <div class="line">      xmlns:bookmark=&quot;http://www.freedesktop.org/standards/desktop-bookmarks&quot;</div>
            <div class="line">      xmlns:mime=&quot;http://www.freedesktop.org/standards/shared-mime-info&quot;&gt;</div>
            <div class="line">  &lt;bookmark href=&quot;ftp://ftp.gnome.org/&quot;&gt;</div>
            <div class="line">      &lt;title&gt;GNOME FTP&lt;/title&gt;</div>
            <div class="line">  &lt;/bookmark&gt;</div>
            <div class="line">&lt;/xbel&gt;</div>
          </div>
          <!-- fragment -->
          <p>Check your Linux-side desktop explorer's "other locations" or network options to discover this connection.</p>
          <h2>
            <a class="anchor" id="autotoc_md28"></a>
            Import your Windows fonts;</h2>
          <div class="fragment">
            <div class="line">$ sudo nano /etc/fonts/local.conf</div>
          </div>
          <!-- fragment -->
          <p>add the following:</p>
          <div class="fragment">
            <div class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</div>
            <div class="line">&lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&gt;</div>
            <div class="line">&lt;fontconfig&gt;</div>
            <div class="line">    &lt;dir&gt;/mnt/c/Windows/Fonts&lt;/dir&gt;</div>
            <div class="line">&lt;/fontconfig&gt;</div>
          </div>
          <!-- fragment -->
          <p>Slick.</p>
          <h2>
            <a class="anchor" id="autotoc_md29"></a>
            User Trash Can setup;</h2>
          <p>The XDG freedesktop specs suggest creating the following directories in your userspaces, for trash can management that integrates widely across a variety of desktop browsers (particularly in the wide world of Linux);</p>
          <div class="fragment">
            <div class="line">$ mkdir $HOME/.local/share/Trash/info</div>
            <div class="line">$ mkdir $HOME/.local/share/Trash/files</div>
            <div class="line">$ mkdir $HOME/.local/share/Trash/expunged</div>
          </div>
          <!-- fragment -->
          <p>The above creates a Trash Can that works properly with, for example, Nautilus and Gnome. The same can (and probably should) be done for the root user. Reading up on the XDG desktop specs is well advised, if you're interested in building from source.</p>
          <h2>
            <a class="anchor" id="autotoc_md30"></a>
            Making the most of your $PATHS variable:</h2>
          <p>In "bash_paths.sh", we have a useful bash logic to check if a directory is present, and if so, to append it to a given variable, such as;</p>
          <div class="fragment">
            <div class="line">if [ -d &quot;/usr/bin&quot; ] ; then</div>
            <div class="line">    PATH=&quot;/usr/bin:$PATH&quot;</div>
            <div class="line">fi</div>
            <div class="line"> </div>
            <div class="line">if [ -d &quot;/usr/local/games&quot; ] ; then</div>
            <div class="line">    PATH=&quot;/usr/local/games:$PATH&quot;</div>
            <div class="line">fi</div>
            <div class="line"> </div>
            <div class="line">if [ -d &quot;$HOME/.local/bin&quot; ] ; then</div>
            <div class="line">    PATH=&quot;$HOME/.local/bin:$PATH&quot;</div>
            <div class="line">fi</div>
            <div class="line"> </div>
            <div class="line">export PATH</div>
          </div>
          <!-- fragment -->
          <p>
            Make sure that you always append (for example) <code>":$PATH"</code>
            in these cases, in order to retain the previously-set values on this variable. The <code>$PATH</code>
            variable in particular <em>should</em> also contain your full Windows PATH variable, when expanded;
          </p>
          <div class="fragment">
            <div class="line">$ echo $PATH</div>
            <div class="line"># This list should contain all your Windows PATH entries as well as your distro&#39;s...</div>
          </div>
          <!-- fragment -->
          <p>
            If you don't see your Windows env paths in the terminal on calling the above, check all of your <code>$PATH</code>
            calls in <code>/etc/profile</code>
            , <code>$HOME/.profile</code>
            , and the <code>/etc/wsl.conf</code>
            interoperability settings. Furthermore, when installing new software on the Linux-side, these occasionally attempt to add further values to certain variables such as <code>$PATH</code>, so try to keep a check on it's output behaviour.
          </p>
          <p>You could adapt a tidy function like the one below, if you prefer (note that the logic differs, though);</p>
          <div class="fragment">
            <div class="line"># Append &quot;$1&quot; to $PATH when not already in.</div>
            <div class="line"># Copied from Arch Linux, see #12803 for details.</div>
            <div class="line">append_path () {</div>
            <div class="line">      case &quot;:$PATH:&quot; in</div>
            <div class="line">              *:&quot;$1&quot;:*)</div>
            <div class="line">                      ;;</div>
            <div class="line">              *)</div>
            <div class="line">                      PATH=&quot;${PATH:+$PATH:}$1&quot;</div>
            <div class="line">                      ;;</div>
            <div class="line">      esac</div>
            <div class="line">}</div>
            <div class="line"> </div>
            <div class="line">append_path &quot;/usr/local/sbin&quot;</div>
            <div class="line">append_path &quot;/usr/local/bin&quot;</div>
            <div class="line">append_path &quot;/usr/sbin&quot;</div>
            <div class="line">append_path &quot;/usr/bin&quot;</div>
            <div class="line">append_path &quot;/sbin&quot;</div>
            <div class="line">append_path &quot;/bin&quot;</div>
            <div class="line">unset -f append_path</div>
            <div class="line"> </div>
            <div class="line">export PATH</div>
          </div>
          <!-- fragment -->
          <h2>
            <a class="anchor" id="autotoc_md31"></a>
            Bash Completion</h2>
          <p>
            Many, perhaps most, modern CLI applications also ship with completion scripts. Though these scripts aren't as prone to frequent updates as the applications themeselves are, there can still be large delays between a vendor's latest stable release version, and the corresponding version bound to APT's default keyring. On top of this, the WSL Ubuntu build in the MS Store also ships with quite a variety of bash completion scripts, split between several different directories (<code>/etc/bash_completion.d</code>
            and <code>/usr/share/bash_completion</code>), which correspond to the application versions... which are bound to APT's default keyring.
          </p>
          <p>
            Thus, if you're binding the latest APT keys as suggested in the [DEVTOOLS KEYRING] section to install latest sotware versions, then you can usually find a 'completion' command (eg <code>supabase completion bash</code>
            ) which you can use to populate whichever bash_completion directories you please, and version-update the content accordingly. Who knows, maybe this could be incorporated into some of the <code>get_app()</code> function definitions, one day.?
          </p>
          <h2>
            <a class="anchor" id="autotoc_md32"></a>
            Storage</h2>
          <p>As seen in the [PRE-INSTALL] step earlier, WSL handily provides lots of ways to manage the storage of our virtual distros, including packing them as .tar files and importing them as dynamically-sized, mountable drives.</p>
          <p>We can fully leverage this in the spirit of a lightweight, portable development environment that can be easily backed up to external storage, re-initialized from a clean slate, duplicated, and converted and transferred between various storages and virtual hard drive formats.</p>
          <p>Let's look at a few things we can do.</p>
          <ul>
            <li>
              option 1; Convert from <code>docker export</code> .tar-format distro named 'Ubuntu' to .vhdx-format distro named 'UBento', while storing a mountable backup (.vhdx) of 'Ubuntu' along the way;
            </li>
          </ul>
          <div class="fragment">
            <div class="line">&gt; wsl --import Ubuntu &quot;D:\Ubuntu&quot; &quot;C:\Users&lt;username&gt;\ubuntu_minimal.tar&quot;</div>
            <div class="line">&gt; wsl --export Ubuntu &quot;D:\Backup\Ubuntu_22_04_1_LTS.vhdx&quot; --vhd</div>
            <div class="line">&gt; wsl --unregister Ubuntu</div>
            <div class="line">&gt; wsl --import UBento &quot;D:\UBento&quot; &quot;D:\Backup\Ubuntu_22_04_1_LTS.vhdx&quot; --vhd</div>
          </div>
          <!-- fragment -->
          <p>
            Note that we imported Ubuntu from a <code>.tar</code>
            file, exported it into a resizeable <code>.vhdx</code>
            , then re-imported that <code>.vhdx</code> under a new distro name.
          </p>
          <p>
            So in fact, the <code>wsl --export/unregister Ubuntu</code>
            steps above are <em>optional</em>
            - you can keep <em>both</em>
            distros on your WSL simultaneously, if you like; simply point the <code>wsl --import</code>
            argument at <em>any</em>
            destination folder, followed by <em>any</em> Linux distro (stored in .tar or .vhd/x format), using whatever unique distro name you like (i.e., 'Ubuntu', 'UBento'...).
          </p>
          <ul>
            <li>
              option 2; Convert an <code>ubuntu.tar</code>
              backup file, to a mounted <code>.vhdx</code> containing distro named 'UBento', without storing a backup;
            </li>
          </ul>
          <div class="fragment">
            <div class="line">&gt; wsl --import UBento &quot;C:\my\install\folder&quot; &quot;C:\my\backup\folder\ubuntu.tar&quot;</div>
          </div>
          <!-- fragment -->
          <ul>
            <li>
              option 3; Just import a <code>.vhd/x</code> from storage directly;
            </li>
          </ul>
          <div class="fragment">
            <div class="line">&gt; wsl --import-in-place &quot;C:\my\install\folder\ubuntu.vhdx&quot;</div>
          </div>
          <!-- fragment -->
          <ul>
            <li>Docker desktop and data storage (including images) can be managed in the exact same way;</li>
          </ul>
          <div class="fragment">
            <div class="line"># Docker front-end storage...</div>
            <div class="line"> </div>
            <div class="line">&gt; wsl --export docker-desktop &quot;D:\Backup\Docker_desktop.vhdx&quot; --vhd</div>
            <div class="line">&gt; wsl --unregister docker-desktop</div>
            <div class="line">&gt; wsl --import docker-desktop &quot;D:\Docker&quot; &quot;D:\Backup\Docker_desktop.vhdx&quot; --vhd</div>
            <div class="line"> </div>
            <div class="line"> </div>
            <div class="line"># Docker back-end storage...</div>
            <div class="line"> </div>
            <div class="line">&gt; wsl --export docker-desktop-data &quot;D:\Backup\Docker_desktop_data.vhdx&quot; --vhd</div>
            <div class="line">&gt; wsl --unregister docker-desktop-data</div>
            <div class="line">&gt; wsl --import docker-desktop-data &quot;D:\Docker\Data&quot; &quot;D:\Backup\Docker_desktop_data.vhdx&quot; --vhd</div>
          </div>
          <!-- fragment -->
          <ul>
            <li>
              All of the above can also be run from another WSL distro's terminal (<code>$</code>) by creating an alias;
            </li>
          </ul>
          <div class="fragment">
            <div class="line">$ alias wsl=&#39;/mnt/c/Windows/System32/wsl.exe&#39;</div>
            <div class="line"> </div>
            <div class="line">$ wsl --import Ubuntu &quot;D:\Ubuntu&quot; &quot;C:\Users&lt;username&gt;\ubuntu_minimal.tar&quot;</div>
            <div class="line"> </div>
            <div class="line"># etc...</div>
          </div>
          <!-- fragment -->
          <h2>
            <a class="anchor" id="autotoc_md33"></a>
            Interoperability with Fonts and Wallpapers</h2>
          <p>
            Notice in the post-install steps the suggestion to use <code>/etc/fonts/local.conf</code> to import your Windows fonts (the entire function is provided in the steps). If you're interested in taking this further, take a look at the MS Store WSL Ubuntu's install folder - it ships with mutliple assets, such as several windows-friendly formats of the famous Ubuntu font, a Yaru-themed wallpaper, and several re-usable icons. The WSL Launcher distro's repo provides artwork templates in various shapes and sizes for shipment to the MS Store. Finally, you can actually get the entire Ubuntu font family - which includes a Windows Terminal-friendly 'monospace' version - from the Ubuntu website*, as well as from common sources such as Google Fonts.
          </p>
          <p>
            While these are probably superfluous touches, they do really highlight the interesting experience of different working environments <em>sharing</em> the resources on one machine in realtime. Personally, I am interested to see how far this can be further leveraged for the purposes of both reducing the linux-side storage footprint, while simultaneously extending the Windows desktop environment into new reaches.
          </p>
          <p>
            *The official Ubuntu fonts are here - <a href="https://design.ubuntu.com/font/">https://design.ubuntu.com/font/</a>
          </p>
          <h2>
            <a class="anchor" id="autotoc_md34"></a>
            X-Server Display Authentication (WIP!)</h2>
          <p>
            <a href="https://en.wikipedia.org/wiki/X_Window_authorization">https://en.wikipedia.org/wiki/X_Window_authorization</a>
          </p>
          <p>(tbc - this is a rough sketch of the idea...)</p>
          <div class="fragment">
            <div class="line">## Just in case...!</div>
            <div class="line">sudo apt install xauth iceauth resolvconf scp</div>
            <div class="line"> </div>
            <div class="line">## Add some Windows-side user environment variables (careful!)</div>
            <div class="line">$ cmd.exe /C setx BASH_ENV /etc/bash.bashrc</div>
            <div class="line">$ cmd.exe /C setx XAUTHORITY $XAUTHORITY</div>
            <div class="line">$ cmd.exe /C setx ICEAUTHORITY $ICEAUTHORITY</div>
            <div class="line">$ cmd.exe /C setx WSLENV BASH_ENV/up:ICEAUTHORITY/up:XAUTHORITY/up</div>
            <div class="line"> </div>
            <div class="line">## Set some easy, portable names...</div>
            <div class="line">$ export ICEAUTHORITY=&quot;$XDG_RUNTIME_DIR/ICEauthority&quot;</div>
            <div class="line">$ export XAUTHORITY=&quot;$XDG_RUNTIME_DIR/Xauthority&quot;</div>
            <div class="line"> </div>
            <div class="line">$ alias iceauth_lin=&#39;iceauth -f $ICEAUTHORITY&#39;</div>
            <div class="line">$ alias xauth_lin=&#39;xauth -f $XAUTHORITY&#39;</div>
            <div class="line"> </div>
            <div class="line">$ alias iceauth_win=&#39;wsl.exe --shell-type login -d ubento --system --user wslg --exec iceauth -f $ICEAUTHORITY&#39;</div>
            <div class="line">$ alias xauth_win=&#39;wsl.exe --shell-type login -d ubento --system --user wslg --exec xauth -f $XAUTHORITY&#39;</div>
            <div class="line"> </div>
            <div class="line">## Screen number</div>
            <div class="line">$ export DISPLAY_NUMBER=&quot;0&quot;</div>
            <div class="line"> </div>
            <div class="line">## Auth key</div>
            <div class="line">$ export DISPLAY_TOKEN=&quot;$(cat &#39;/etc/resolv.conf&#39; | tr -d &#39;\n\r&#39; | md5sum | gawk &#39;{print $1;}&#39; )&quot;</div>
            <div class="line"> </div>
            <div class="line">## Server address</div>
            <div class="line">$ export DISPLAY_ADDRESS=&quot;$(cat &#39;/etc/resolv.conf&#39; | grep nameserver | awk &#39;{print $2; exit;}&#39; )&quot;</div>
            <div class="line"> </div>
            <div class="line">## Encrypted X session address</div>
            <div class="line">$ export DISPLAY=&quot;$DISPLAY_ADDRESS:$DISPLAY_NUMBER.$DISPLAY_TOKEN&quot;</div>
            <div class="line"> </div>
            <div class="line">## Unencrypted X session address (if authentication fails, swap the above for this...)</div>
            <div class="line"># export DISPLAY=&quot;$DISPLAY_ADDRESS:$DISPLAY_NUMBER.0&quot;</div>
            <div class="line"> </div>
            <div class="line">## GL rendering - worth experimenting with these two!</div>
            <div class="line">$ export LIBGL_ALWAYS_INDIRECT=1</div>
            <div class="line">$ export GDK_BACKEND=x11</div>
            <div class="line"> </div>
            <div class="line"> </div>
            <div class="line">$ auth_x()</div>
            <div class="line">{</div>
            <div class="line">    if [ -z &quot;$DISPLAY&quot; ]; then</div>
            <div class="line">        echo &quot;Error: DISPLAY environment variable is not set.&quot;</div>
            <div class="line">    else</div>
            <div class="line"> </div>
            <div class="line">        echo &quot;Display set to: $DISPLAY\n&quot;</div>
            <div class="line">        # Will print your encrypted X address...</div>
            <div class="line"> </div>
            <div class="line">        echo &quot; Windows X Server keys: \n&quot; &amp;&amp; xauth_win list</div>
            <div class="line">        echo &quot; Linux X Server keys: \n&quot; &amp;&amp; xauth_lin list</div>
            <div class="line"> </div>
            <div class="line">        # Authorize key on Linux side and pass to Windows</div>
            <div class="line">        xauth_lin add $DISPLAY_ADDRESS:$DISPLAY_NUMBER . $DISPLAY_TOKEN</div>
            <div class="line">        xauth_win generate $DISPLAY_ADDRESS:$DISPLAY_NUMBER . trusted timeout 604800</div>
            <div class="line"> </div>
            <div class="line">        # Vice-versa...</div>
            <div class="line">        xauth_win add $DISPLAY_ADDRESS:$DISPLAY_NUMBER . $DISPLAY_TOKEN</div>
            <div class="line">        xauth_lin generate $DISPLAY_ADDRESS:$DISPLAY_NUMBER . trusted timeout 604800</div>
            <div class="line"> </div>
            <div class="line">        echo &quot;Windows X Server keys:&quot; &amp;&amp; xauth_win list</div>
            <div class="line">        echo &quot;Linux X Server keys:&quot; &amp;&amp; xauth_lin list</div>
            <div class="line"> </div>
            <div class="line">    fi</div>
            <div class="line"> </div>
            <div class="line">    # Notes;</div>
            <div class="line">    # WIP!!!</div>
            <div class="line">    # Useage of cp should be substituted for scp, possibly via SSH...?</div>
            <div class="line">}</div>
          </div>
          <!-- fragment -->
          <p> Call the authentication function (this still needs some work - stay tuned!);</p>
          <div class="fragment">
            <div class="line">auth_x</div>
          </div>
          <!-- fragment -->
          <h2>
            <a class="anchor" id="autotoc_md35"></a>
            Windows Terminal and launcher</h2>
          <p>It's easy to launch UBento from the excellent new Windows Terminal app, by simply creating a new profile named "UBento" and with the following command line invocation;</p>
          <div class="fragment">
            <div class="line">C:\WINDOWS\system32\wsl.exe -d UBento</div>
          </div>
          <!-- fragment -->
          <p>Launching this profile should place you directly in your home folder as your user, which in turn will also call the initialization routines we have set up so far.</p>
          <p>Going deeper, we could make a simple desktop-icon launcher that simply invokes our Windows Shell and runs the above command.... (possibly coming soon). Meanwhile, you're welcome to copy my UBento launcher settings (this Windows Terminal profile launches you directly into your user home directory, with the init steps taken care of) into your "Windows Terminal &gt; Settings &gt; Open JSON File" by adding the following;</p>
          <div class="fragment">
            <div class="line">{</div>
            <div class="line">    &quot;$help&quot;: &quot;https://aka.ms/terminal-documentation&quot;,</div>
            <div class="line">    &quot;$schema&quot;: &quot;https://aka.ms/terminal-profiles-schema&quot;,</div>
            <div class="line">    &quot;profiles&quot;:</div>
            <div class="line">    {</div>
            <div class="line">        &quot;list&quot;:</div>
            <div class="line">        [</div>
            <div class="line">            {</div>
            <div class="line">                &quot;colorScheme&quot;: &quot;StoneyDSP&quot;,</div>
            <div class="line">                &quot;hidden&quot;: false,</div>
            <div class="line">                &quot;icon&quot;: &quot;C:\\Users\\{username}\\repos\\ubento\\ubento.png&quot;,</div>
            <div class="line">                &quot;name&quot;: &quot;UBento&quot;,</div>
            <div class="line">                &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;</div>
            <div class="line">            }</div>
            <div class="line">        ]</div>
            <div class="line">    },</div>
            <div class="line">    &quot;schemes&quot;:</div>
            <div class="line">    [</div>
            <div class="line">        {</div>
            <div class="line">            &quot;background&quot;: &quot;#300A24&quot;,</div>
            <div class="line">            &quot;black&quot;: &quot;#000000&quot;,</div>
            <div class="line">            &quot;blue&quot;: &quot;#0000CC&quot;,</div>
            <div class="line">            &quot;brightBlack&quot;: &quot;#444444&quot;,</div>
            <div class="line">            &quot;brightBlue&quot;: &quot;#0000FF&quot;,</div>
            <div class="line">            &quot;brightCyan&quot;: &quot;#00FFFF&quot;,</div>
            <div class="line">            &quot;brightGreen&quot;: &quot;#00FF00&quot;,</div>
            <div class="line">            &quot;brightPurple&quot;: &quot;#FF00FF&quot;,</div>
            <div class="line">            &quot;brightRed&quot;: &quot;#FF0000&quot;,</div>
            <div class="line">            &quot;brightWhite&quot;: &quot;#FFFFFF&quot;,</div>
            <div class="line">            &quot;brightYellow&quot;: &quot;#FFFF00&quot;,</div>
            <div class="line">            &quot;cursorColor&quot;: &quot;#FFFFFF&quot;,</div>
            <div class="line">            &quot;cyan&quot;: &quot;#00CCCC&quot;,</div>
            <div class="line">            &quot;foreground&quot;: &quot;#FFFFFF&quot;,</div>
            <div class="line">            &quot;green&quot;: &quot;#00CC00&quot;,</div>
            <div class="line">            &quot;name&quot;: &quot;StoneyDSP&quot;,</div>
            <div class="line">            &quot;purple&quot;: &quot;#CC00CC&quot;,</div>
            <div class="line">            &quot;red&quot;: &quot;#CC0000&quot;,</div>
            <div class="line">            &quot;selectionBackground&quot;: &quot;#FFFFFF&quot;,</div>
            <div class="line">            &quot;white&quot;: &quot;#CCCCCC&quot;,</div>
            <div class="line">            &quot;yellow&quot;: &quot;#CCCC00&quot;</div>
            <div class="line">        }</div>
            <div class="line">    ]</div>
            <div class="line">}</div>
          </div>
          <!-- fragment -->
          <p>
            The profile's 'command line' option should be set to <code>C:\WINDOWS\system32\wsl.exe -d UBento</code>
            - you can also append <code>--user {username}</code> if you like.
          </p>
          <h2>
            <a class="anchor" id="autotoc_md36"></a>
            Accessing the underlying WSL2 Linux Kernel (CL Mariner Linux)</h2>
          <p>
            Microsoft's WSL2 is, functionally speaking, a re-branded custom Linux kernel that has been adapted to run as a shell environment natively on Windows drivers. This custom kernel is Microsoft's ArchLinux-based CL-Mariner Linux kernel, which can be found in their Git repos (will link shortly). This custom kernel (which runs natively on Windows) mounts your chosen Linux distro (in it's own <code>/mnt</code>
            folder) and provides it's Windows-friendly systemd and GUI libraries to your distro, acting as a kind of bridge between both environments, and thus allowing your chosen Linux distro to "pipe" it's data to and from your Windows OS environment. The actual kernel used to do this can in fact be customized/changed by use of the Windows'side <code>C:\Users\{username}\.wslconfig</code>
            file. It is quite useful to note that you can in fact use a Windows command-line argument to login to your WSL2 distro as one of two "system"-level users, which will actually log you in to the Microsoft ArchLinux-based CL-Mariner kernel, which is the very heart of your WSL install - here, I present a series of commands to log in to CL-Mariner as the 'root' user, obtain the <code>sudo</code> package, and then proceed as the default-user (pre-named 'WSLg') with full sudo/yum package manager access;
          </p>
          <div class="fragment">
            <div class="line"># The &#39;--system&#39; flag accesses the underlying kernel as &#39;--user root&#39;;</div>
            <div class="line">&gt; wsl --distro ubento --system --user root</div>
            <div class="line"> </div>
            <div class="line"># The above should have you logged in as a root user with a red-colored prompt for the below;</div>
            <div class="line">$ no | yum update</div>
            <div class="line">$ yum install sudo</div>
            <div class="line">$ sudo passwd WSLg</div>
            <div class="line"># create and confirm a desired password for user &#39;wslg&#39;, can be anything... I&#39;ve no idea what the default is set to!</div>
            <div class="line">$ usermod --group=adm,dialout,cdrom,floppy,tape,sudo,audio,dip,video wslg</div>
            <div class="line">$ login wslg</div>
            <div class="line"># Enter the password you had just created to log in as user &#39;wslg&#39; - you should now have a green-colored prompt;</div>
            <div class="line">$ sudo yum update</div>
            <div class="line">$ sudo yum upgrade -y</div>
            <div class="line">$ sudo yum install nano vim</div>
            <div class="line"># etc... in fact, don&#39;t forget to check the &#39;/etc&#39; folder, as well as the two user directories, for some interesting bashscripts :)</div>
          </div>
          <!-- fragment -->
          <p>Now, while still logged in with the '&ndash;system' flag, take a look here;</p>
          <div class="fragment">
            <div class="line">$ cd /mnt/wslg/runtime-dir</div>
            <div class="line">$ ls -la</div>
          </div>
          <!-- fragment -->
          <p>Take note of the contents, such as the wayland and pulseaudio stuff...</p>
          <p>Once you log out of '&ndash;system' and back in to your distro as per normal, do this;</p>
          <div class="fragment">
            <div class="line">$ cd $XDG_RUNTIME_DIR</div>
            <div class="line">$ ls -la</div>
          </div>
          <!-- fragment -->
          <p>It turns out to be the same folder, right? It seems the runtime directory itself is something of a symlink, or portal, between your running distro, and the underlying CL-Mariner kernel.</p>
          <p>Launch a few keyrings and services, then check the contents again...</p>
          <div class="fragment">
            <div class="line">$ sudo service dbus start</div>
            <div class="line">$ /usr/libexec/at-spi-bus-launcher --launch-immediately --a11y=1 &amp;</div>
            <div class="line">$ google-chrome 2&gt;/dev/null &amp;</div>
            <div class="line">$ code $HOME</div>
            <div class="line">$ ls -la $XDG_RUNTIME_DIR</div>
          </div>
          <!-- fragment -->
          <p>
            Since this particular location (as found at $XDG_RUNTIME_DIR) is accessible on both the Windows <em>and</em> Linux sides, it seems to be a perfect candidate for storing shared cookies, socket connections, and other temp runtime data.
          </p>
          <p>
            You should note that this underlying kernel is re-formatted every time it is cold-booted (that is, all previous WSL sessions closed, then launching a new session). Any changes you make here do not persist once WSL goes offline, such as with <code>wsl --shutdown</code>. Without further testing, I believe this has something to do with a persistent system variable that is hard-wired to the WSL2 distro-launcher's command line (something like "WSL_ROOT_INIT=1"...), and that it may be possible to control or influence the bahviour of this variable; as to what end, I'm not particularly sure. You can actually clone the latest build of MS's CL-Mariner kernel from their Git repo, along with instructions on how to build it from source (plus the usage instructions found in the '.wslconfig' documentation). They do also provide some encouragement for user to 'tinker' with the kernel to their own ends.
          </p>
          <h2>
            <a class="anchor" id="autotoc_md37"></a>
            Customisation and tailoring your build to focus only on your needs</h2>
          <ul>
            <li>
              A lot of the latest Linux releases of popular coding tools, like NodeJs and CMake, don't have any additional package dependencies in order to be installed and used. WSL-integrated Windows apps like VSCode and Docker Desktop also "just work" straight from the box. Dependencies aside, most Linux GUI apps will happily launch from their Windows icons - or bash shell commands - without any additional self-configuring of, or even launching of, the X-Server. The requirements to run a full visual desktop environment are where the majority of the costs lie; and with otherwise such low runtime integration requirements and portability, the benefits of having a secondary visual desktop environment <em>on your native visual desktop environment</em>
              don't necessarily outweight the performance costs when you really need it most, IME. If your main interest is in getting critical work done, you likely don't need much more than to <code>unminimize</code> and add a few packages to the keyring, if that. But if what you want is to have a deep and performant Linux experience integrated directly within your Windows environment, you can have that too.
            </li>
            <li>
              You can choose not to <code>unminimize</code> if you want your distro to be as compact as possible (for CI/Docker runs, for example). As of writing, this command will less-than-double the size of the install on disk; Without it, however, there are a large amount of quite low-level symlinks and base libraries missing - though you can still build all the way up to the full equivalent environment of the MS Store version, one package dependency cycle at a time. But if you're skipping it, your bash and apt command line responses might seem quite strange and present you with unfamiliar prompts and errors. While these are often just harmless indicators - especially in short-term runs - you will probably want to accomodate some of their requests and ignore others. Always good test your distro setup with a few manual run-throughs on the terminal!
            </li>
            <li>
              Systemd-dependent services and apps are a big investment beyond the original minimized state of the distro, but are often key to having a stable, more robust (certainly mid/long-term) working environment. My suggestion is to avoid systemd for CI/Docker runs, and embrace it for desktop and GUI stuff; same goes for <code>unminimize</code>.
            </li>
            <li>
              Name your distro's host server. It's a good idea to use 'localhost' or at least something different to your Windows Machine ID as your WSL distro's hostname (this is set in <code>/etc/wsl.conf</code>). The unfortunate current default is to simply copy the Win MachineID over to WSL userland. I personally like "localclient" for my Windows machine, and "localhost" for my WSL distro - this is a nice distinction when you are presented with network addresses that point to either 'localclient' or 'localhost'. When launching Node apps, for example, you can view them in your "localclient"'s browser (i.e., your net browser for Windows) and differentiate the network addresses your code backend provides from "localhost", for example. This is also very useful when configuring the X-server, especially, where keys might be exchanged both ways.
            </li>
          </ul>
          <h2>
            <a class="anchor" id="autotoc_md38"></a>
            Git tip from microsoft WSL docs</h2>
          <p>
            When handling a single repo on both your Windows and Linux file systems, it's a good idea to weary of line endings. Microsoft suggests adding a <code>.gitattributes</code> to the repo's root folder with the following, to ensure that no script files are corrupted;
          </p>
          <div class="fragment">
            <div class="line">* text=auto eol=lf</div>
            <div class="line">*.{cmd,[cC][mM][dD]} text eol=crlf</div>
            <div class="line">*.{bat,[bB][aA][tT]} text eol=crlf</div>
          </div>
          <!-- fragment -->
          <h2>
            <a class="anchor" id="autotoc_md39"></a>
            Make yourself a local-storage "~/Development" directory, and do cool stuff in there</h2>
          <div class="fragment">
            <div class="line">$ mkdir &quot;$HOME/Development&quot;</div>
            <div class="line">$ export DEV_DIR=&quot;$HOME/Development&quot;</div>
            <div class="line">$ cd &quot;$DEV_DIR&quot;</div>
            <div class="line"> </div>
            <div class="line">$ git clone git@github.com:StoneyDSP/ubento.git</div>
            <div class="line"> </div>
            <div class="line"># If you&#39;re cd-&#39;ing around between NodeJs-based repo&#39;s, consider checking out nvm-sh&#39;s &#39;cd_nvm&#39; function :)</div>
          </div>
          <!-- fragment -->
          <h2>
            <a class="anchor" id="autotoc_md40"></a>
            Shutting down</h2>
          <p>
            Note that if you choose not to <code>unminimize</code> your distro, not install systemd, or otherwise have no real shutdown strategy in your distro, you can always
          </p>
          <div class="fragment">
            <div class="line">$ alias shutdown=&quot;wsl.exe -d &lt;myDistro&gt; --shutdown &amp;&amp; logout&quot;</div>
          </div>
          <!-- fragment -->
          <p>then</p>
          <div class="fragment">
            <div class="line">$ shutdown</div>
          </div>
          <!-- fragment -->
          <h2>
            <a class="anchor" id="autotoc_md41"></a>
            [REFERENCES AND SOURCES]</h2>
          <h2>
            <a class="anchor" id="autotoc_md42"></a>
            Microsoft WSL docs</h2>
          <ul>
            <li>
              <a href="https://learn.microsoft.com/en-us/windows/wsl/">https://learn.microsoft.com/en-us/windows/wsl/</a>
            </li>
          </ul>
          <h2>
            <a class="anchor" id="autotoc_md43"></a>
            Docker Desktop for Win/WSL2 docs</h2>
          <ul>
            <li>
              <a href="https://docs.docker.com/desktop/windows/wsl/">https://docs.docker.com/desktop/windows/wsl/</a>
            </li>
          </ul>
          <h2>
            <a class="anchor" id="autotoc_md44"></a>
            Microsoft VSCode WSl &amp; Remote Development Extension docs</h2>
          <ul>
            <li>
              <a href="https://code.visualstudio.com/docs/remote/troubleshooting#_wsl-tips">https://code.visualstudio.com/docs/remote/troubleshooting#_wsl-tips</a>
            </li>
            <li>
              <a href="https://code.visualstudio.com/docs/remote/wsl">https://code.visualstudio.com/docs/remote/wsl</a>
            </li>
            <li>
              <a href="https://learn.microsoft.com/en-us/cpp/build/walkthrough-build-debug-wsl2?view=msvc-170">https://learn.microsoft.com/en-us/cpp/build/walkthrough-build-debug-wsl2?view=msvc-170</a>
            </li>
          </ul>
          <h2>
            <a class="anchor" id="autotoc_md45"></a>
            X410 cookbook</h2>
          <ul>
            <li>
              <a href="https://x410.dev/cookbook/wsl/running-ubuntu-desktop-in-wsl2/">https://x410.dev/cookbook/wsl/running-ubuntu-desktop-in-wsl2/</a>
            </li>
          </ul>
          <h2>
            <a class="anchor" id="autotoc_md46"></a>
            SO thread about X server encryption</h2>
          <ul>
            <li>
              <a href="https://stackoverflow.com/questions/61110603/how-to-set-up-working-x11-forwarding-on-wsl2?noredirect=1&lq=1">https://stackoverflow.com/questions/61110603/how-to-set-up-working-x11-forwarding-on-wsl2?noredirect=1&amp;lq=1</a>
            </li>
          </ul>
          <h2>
            <a class="anchor" id="autotoc_md47"></a>
            Sharing environment variables between Windows and Linux;</h2>
          <ul>
            <li>
              <a href="https://devblogs.microsoft.com/commandline/share-environment-vars-between-wsl-and-windows/">https://devblogs.microsoft.com/commandline/share-environment-vars-between-wsl-and-windows/</a>
            </li>
            <li>
              <a href="https://superuser.com/questions/1745166/verify-that-config-value-applied-in-wsl">https://superuser.com/questions/1745166/verify-that-config-value-applied-in-wsl</a>
            </li>
          </ul>
          <h2>
            <a class="anchor" id="autotoc_md48"></a>
            Package keys;</h2>
          <ul>
            <li>Please see respective repos on GH, and study the "get key" routine as found here and elsewhere;</li>
            <li>
              <a href="https://apt.kitware.com/">https://apt.kitware.com/</a>
            </li>
          </ul>
        </div>
      </div>
      <!-- PageDoc -->
    </div>
    <!-- contents -->

    <!-- HTML footer for doxygen 1.9.7-->
    <!-- start footer part -->
    <hr class="footer">
    <address class="footer">
      <small>
        Generated by&#160;<a href="https://www.doxygen.org/index.html">
          <img class="footer" src="public/doxygen.svg" width="104" height="31" alt="doxygen">
        </a> 1.9.7
      </small>
    </address>
    <address class="footer">
      <a href="https://www.vercel.com/index.html" class="footer" alt="vercel">
        <div class="footer vercel">&#160;</div>
      </a>
    </address>

  </body>
</html>
